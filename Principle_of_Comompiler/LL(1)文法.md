
LL(1) 文法是一种确定性的上下文无关文法（CFG），适用于**自顶向下语法分析**。其名称中的 "LL" 表示：
- **L**：从左到右扫描输入（Left-to-right scanning）。
- **L**：生成最左推导（Leftmost derivation）。
- **(1)**：只需向前查看**1个输入符号**即可确定语法分析动作。

---

### **核心条件**
一个文法 \( G \) 是 LL(1) 文法，当且仅当对于文法中的**每一个非终结符 \( A \)** 及其所有产生式 \( A \to \alpha_1 \mid \alpha_2 \mid \dots \mid \alpha_n \)，满足：
\[ \text{FIRST}(\alpha_i) \cap \text{FIRST}(\alpha_j) = \emptyset \quad (i \neq j) \]
且如果 \( \alpha_i \) 可以推导出空串 \( \varepsilon \)，则还需满足：
\[ \text{FIRST}(\alpha_j) \cap \text{FOLLOW}(A) = \emptyset \quad (i \neq j) \]

---

### **关键概念**
1. **FIRST(α) 集合**：  
   - 定义：能从 \( \alpha \) 推导出的所有**终结符串的第一个符号**（包括 \( \varepsilon \) 如果 \( \alpha \Rightarrow^* \varepsilon \)）。
   - 用途：决定选择哪个产生式展开。

2. **FOLLOW(A) 集合**：  
   - 定义：在句型中可能**紧跟在非终结符 \( A \) 后面的终结符**（包括结束符 \( \$ \)）。
   - 用途：处理 \( A \) 能推导出 \( \varepsilon \) 的情况。

---

### **为什么需要 LL(1) 条件？**
- **避免回溯**：分析时只需看下一个输入符号即可确定使用哪条产生式，无需尝试多种可能。
- **确保确定性**：如果 FIRST 或 FOLLOW 集合有交集，分析器无法唯一决定产生式，导致冲突。

---

### **例子**
考虑文法：
\[
S \to aS \mid b
\]
- **FIRST(aS) = {a}**，**FIRST(b) = {b}**，无交集，且无 \( \varepsilon \) 产生式。  
- 是 LL(1) 文法。

而非 LL(1) 的文法示例：
\[
S \to aS \mid a
\]
- **FIRST(aS) = FIRST(a) = {a}**，产生交集，分析器无法根据下一个符号 `a` 选择正确的产生式。

---

### **LL(1) 分析表构建**
通过计算每个非终结符的 FIRST 和 FOLLOW 集合，可以填充预测分析表 \( M[A, a] \)（表示在非终结符 \( A \) 和输入符号 \( a \) 下应选择的产生式）。

---

### **局限性**
- 不是所有上下文无关文法都是 LL(1)（例如左递归文法或二义性文法无法满足 LL(1) 条件）。
- 更强大的分析器（如 LR 分析器）能处理更复杂的文法。

---

总结来说，LL(1) 文法通过严格的 FIRST/FOLLOW 集合限制，保证了语法分析的高效性和确定性，是编译原理中自顶向下分析的重要基础。
