
  

  

  

  

## 第二章

  

  

  

  

  

主要围绕PL/0语言展开

  

  

  

  

### PL/0语言的特点：

  

  

  

  

  

1. PL/0语言是混合型语言，类似于java，先由编译器生成的**Pseudo Pcode**，再将Pseudo Pcode交由解释器直接生成结果

  

  

  

  

2.

  

  

  

  

![feature](https://i.imgur.com/LLWt09j.png)

  

  

  

  

如上图所示，PL/0语法有很多特点：变量类型只有整型、 函数嵌套的层级上限是3 、少量的控制语句

  

  

  

  

  

#### 以上特点的示例

  

  

  

  

![一个真实的案例](https://i.imgur.com/nJk0Ovh.png)

  

  

  

  

1. PL/0中没有函数只有过程(*program*)，一个过程由*program*关键字和过程名组成，并且过程类似函数是可以带参数的，如 *PROGRAM add(a,b);* 也是可以的

  

  

  

  

  

2. 使用 *VAR* 关键字声明整形，因为除了整形就是常量

  

  

  

  

  

3. 局部变量是非常重要的内容，这直接影响了接下来Pseudo Pcode的编码，图中标注的 *Main Procedure* 拥有 level = 0的层级，观察可以发现 *Procedure P* 和 *Main Procedure* 所定义的变量B,C是处于同一层级的，所以 *Procedure P* 拥有 level = 1的层级，类似，*Procedure Q* 拥有level = 2的层级

  

  

  

  

4. 在自己的过程 *(Procedure)* 中定义的变量为局部变量，每一个过程拥有使用level更小层级定义的变量的权力，如：*Procedure Q* 可以使用变量D（这是在*Procedure P*中定义的)， *Main Procedure* 可以 调用 *(call)*  *Procedure P*，这个相当于它自己定义的变量一样。

  

  

  

  

5. 但是level小的层级不能使用level大的层级，这很好理解，就是作用域的范围问题，比如：P < Q 而 main < P 所以main无法调用Q定义的变量

  

  

  

  

  

### 来个编译后的实例

  

  

  

  

![instruction set](https://i.imgur.com/5JIf3mV.png)

  

  

  

  

![编译过的实例](https://i.imgur.com/CMzY4Ib.png)

  

  

  

  

1. 首先，编译生成的Pseudo Pcode代码顺序 完全等同于源代码的顺序

  

  

  

  

2. 指令集第一行参数为level_diffrence，它的意义是你所操作的对象和你当前过程的level 差，比如：第三条 lod 1 3，这条语句是对变量b进行取的操作，该过程是 *Procedure p*，但是操作的变量b却是在 *main Procedure*中定义的，所以level_diffrence = 1 - 0 =1，**注意，只有Load取 store存 call调用 这三个过程有level diference**

  

  

  

  

  

3. 结合指令集观察我们的代码发现，虽然按照顺序编译，但是第一条指令并不直接分配空间，这是一条跳转指令，要求跳转到第8条指令执行，到第2条指令我们才为变量b,c分配了空间

  

  

  

  

4. opr 0 0，这条语句由上面的指令集可知这是返回调用的命令，相当于return

  

  

  

  

  

#### 以上值得注意的是，调用过程 *(call)* 是动态的，因为有可能调用是有条件的，只有实际运行时才能决定是否调用，而定义是静态的，编译完就已经固定不变

  

  

  

  

  

## 第三章

  

  

  

  

第三章的重点还是词法分析，在本章中我们关注单词的形式化描述，如使用正规式描述一个单词的构成，或者使用有向的状态转换图描述我们的单词

  

  

  

  

  

以下是一个短句的各部分成分

  

  

  

  

![如图](https://i.imgur.com/6OSwiZC.png)

  

  

  

  

  

1.词法分析的目的在于把输入的字符串分割成一个又一个的词语，然后再把每个词语划分token class,如上图所示，一个词可以是关键字，标识符，数字和分隔符

  

  

  

  

  

2.值得注意的是，有时，我们不能读了一个字符就马上决定它是什么，需要再向前读多一位，因为有可能是一个俩个字符组成的操作符, ** 例如 '<' 和 '<=' **

  

  

  

  

  

**词法分析的步骤可以用这个流程图来表示**

  

  

  

  

![词法分析流程图](https://i.imgur.com/ViwBYFN.png)

  

  

  

  

注意其中有个二分查找的过程，在 Is ID a KEYWORD 中

  

  

  

  

  

### 正规式

  

  

  

  

1.基本运算

  

  

  

  

![正规式的基本操作](https://i.imgur.com/KLQ4pZV.png)

  

  

  

  

上图是正规式的集中运算 其**主要有三种操作 a | b (或), ab(连接), a*(星闭包) ** ，其中三者的优先级是星闭包>连接>或

  

  

  

  

  

首先，**ϵ**代表一个空字符串，也就是说匹配到空字符就用这个符号表示，所以空串函数操作后还是空串

  

  

  

  

  

运算 * A|B * 相当于 一个或运算，说明这个位置有两种可能性既可以是A也可以是B,但是最终只有一种确定的可能性

  

  

  

  

  

运算AB是一个看不见的隐式调用，读作A连接B，这其实暗含了顺序的特点，即字符A在前，字符B紧跟其后

  

  

  

  

  

运算A*读作A的星闭包，其意思是可能的集合有**ϵ**, **A**, **AA**, **AAA**.......一直到无穷多个都是有可能的

  

  

  

  

运算A+读作A的正闭包，它和星闭包唯一的区别就是它不可能是空串

  

  

  

  

  

**详细展开如图所示**

  

  

  

  

![详细展开](https://i.imgur.com/dNMC7xm.png)

  

  

  

  

  

#### 具体详细的中文定义如下

  

  

  

  

![详细的中文定义](https://i.imgur.com/uH1Q6oj.png)

  

  

  

  

  

2.详细的例子

  

  

  

  

![详细的例子](https://i.imgur.com/pXgI7PY.png)

  

  

  

  

上述正规式我都写了关于串长度的下界，这些下界是有正规式的预算法则决定的，比如第一个ba*，串中肯定有b，但是a*可能是空串到无穷，所以长度至少大于1

  

  

  

  

  

需要注意的是倒数第一、二个，(aa|ab|ba|bb)*这个输出要么是空串，要么就只会是偶数长度的串

  

  

  

  

  

倒数第一个(a|b)(a|b)等价于(aa|ab|ba|bb)

  

  

  

  

  

3.满足的运算律

  

  

  

  

![满足的运算律](https://i.imgur.com/Zox8sWR.png)

  

  

  

  

  

#### 例题

  

  

  

  

![例题](https://i.imgur.com/ZKdST2g.png)

  

  

  

  

  

要判断三个表达式是否等价，就需要知道他们是不是能处理的串完全相同，可以尝试把三个式子展开

  

  

  

  

(a|b)* = (a|b)(a|b)(a|b)...(a|b),同理可得其它

  

  

  

  

  

需要注意优先级的问题，()的优先级最高

  

  

  

  

第三个 ((**ϵ**|a)b*)，由分配律可得等价于(b*|ab*),展开后可知三者所能实现的串应该是一样的所以三者等价

  

  

  

  

  

#### 作业

  

  

  

  

![正则式作业](https://i.imgur.com/UAFsBb4.jpeg)

  

  

  

  

我的答案显然是错误的，它的确可以表示出任意长度的空串，但**问题是我的答案表示出的不仅仅是任意长度的空串，还包括了空串和长度为偶数的串**，正确答案应该为** (a|b) ( (a|b) (a|b) )* **,在确保里面的串是偶数的情况下，在选择a或b就成了奇数串

  

  

  

  

  

### 自动机

  

  

  

  

------

  

  

  

  

**NFA 有着自身的缺点，比如时间开销过大**所以我们需要将NFA确定化为DFA,这主要是用到两种操作，首先是把**空闭包**(**ϵ**)计算出来，然后在把从一种状态到另一种状态的条件找出来 *move*

  

  

  

![操作](https://i.imgur.com/T8u9ppv.png)

  

  

  

1.所谓求空闭包，就是求一个状态经过空串**ϵ**，所能到达的所有状态的集合

  

  

  

  

2.求move，就是一个包含所有空闭包的集合经过一次条件转换所能达到的空闭包状态集合

  

  

  

  

#### 空闭包实例

  

  

  

![实例](https://i.imgur.com/3q1zzU0.png)

  

  

  

对**B**求空闭包:自身一定包含，**C,D**空串可达

  

  

  

对**G**求空闭包:到**A**空串可达，**A**可达的也需要包括

  

  

  

  

#### 实际求解步骤

  

  

  

![实际求解](https://i.imgur.com/ZZU14eJ.png)

  

  

  

1. 首先我们要求出关于原NFA初态的空闭包，在以上例子中就是求出**A**的空闭包。

  

  

  

2. 然后明确有多少个输入，在以上例子中一共就是0,1两种输入，这就是move

  

  

  

3. 拿着初态空闭包集，判断该集合中每一个状态接受了输入之后会跳转到哪个状态，并且到达该状态后可以由空闭包活得其它的哪些状态，比如空闭包中的**D**接受一个输入0跳转到**F**，而**F**空闭包可以得到**G**,**H**,**I**

  

  

4. 最后得到的新终态是包含原来终态(在本例中是**J**)的集合，如果原自动机中有多个终态，那只需要包括其中一个终态即可

  

  

  

  

#### 状态转换图和实现表

  

  

  

![](https://i.imgur.com/OEzkr2i.png)

  

  

  

**两个可以互相转换，都要考**

  

  

  

  

以下是一道关于由状态转换图画实现表的例题

  

  

  

![](https://i.imgur.com/gHF5wbd.png)

  

  

  

值得注意的一点是多一个或者少一个状态都不是相同的集合

  

  

  

每move一次得到一个集合就添加到纵向的状态栏中

  

  

  

**最好每个在状态标记一个字母，这样不容易错**

  

  

  

## 第四章

  

  

本章讲语法分析，是有关**CFG(上下文无语言)**的章节，CFG是全书的重点内容，是最重要的形式化工具

  

  

  

#### 前面我们学过了很多的形式化工具，但是无论是正则公式，还是自动机都有其表示的局限性，例如

  

  

![问题实例](https://i.imgur.com/2HCGTSe.png)

  

  

以上例子要求表示括号的成对性，但是无论是正则式还是自动机都无法表示括号的成对出现

  

  

  

而**CFG就是可以控制出现次数的语言**

  

  

  

![](https://i.imgur.com/Pm71OXD.png)

  

  

在这个例子中，自动机可以确保1出现的次数必定是奇数，但是0的数量无法控制，并且无论是0或1，都无法控制实际出现的次数

  

  

  

#### 语法分析一定会生成一颗语法树，例如:

  

  

![语法树](https://i.imgur.com/riCOQSn.png)

  

  

这就是一颗语法树，当我们把语法框架IF-THEN-ELSE抽离出来，用二元运算符作为语法树的节点

  

  

  

---

  

  

![](https://i.imgur.com/bKV6g83.png)

  

  

递归嵌套的声明是CFG的重要内容，以上例子中，EXPR表达式还可以循环代入，这就是推导*(derivation)*的重要内容

  

  

  

#### CFG的组成

  

  

![组成](https://i.imgur.com/gKerlaJ.png)

  

  

  

1.终结符集(小写)

  

  

2.非终结符集(大写)

  

  

3.开始符

  

  

4.产生式集

  

  

  

***其中终结符集不可被替换，非终结符集会被替换，开始符也许只有一个，我们依赖于产生式集做推导***

  

  

  

#### 详细(derivation)推导的过程

  

  

![](https://i.imgur.com/Luwd0jo.png)

  

  

1.产生式集左边称为左部，右边为右部

  

  

2.推导过程就是不断使用左部替代有右部的过程，直到没有终结符

  

  

3.归约*(reduction)*是推导的逆过程，就是从结果反推解析产生式

  

  

![](https://i.imgur.com/QRhIwUT.png)

  

  

  

![](https://i.imgur.com/81wH0UN.png)

  

  

我们通过产生式将非终结字符替换成终结字符

  

  

  

![星推导](https://i.imgur.com/2nQMvUu.png)

  

  

这个推导可以包含0步到无穷多步的推导，但是一般不常用到

  

  

  

![推导例子](https://i.imgur.com/JFQRM2W.png)

  

  

  

![答案](https://i.imgur.com/22E5tRP.png)

  

  

**注意语法树一定要画**

  

  

非终结式就是可以一直推导下去的部分

  

  

----

  

#### 接下来来看一个相当重要的推导实例

  

![](https://i.imgur.com/QLvio6l.png)

  

以上是一条产生式和需要达成的最终推导结果

  

  

![文法推导以及语法树](https://i.imgur.com/pES24L2.png)

  

以上就是上述题目的文法推导和相应的语法树生成，其中有几点需要**注意**的:

  

1. 推导式从启动符**(本题是E)**开始，由产生式表明的关系推导

  

2. 语法树的中每个非叶节点都对应产生式的左部，而它的子节点要对应相应产生式的右部

  

  

3. 在推导式中任意一个符号(终结与非终结)都必须有它自己的分支，如图中画红圈的**'+'**,哪怕不能继续推导也必须有自己的分支，又如最后是空串 **ϵ**，也要写到语法树中

  

4. 文法推导**一次只允许做一步操作**，如以上例子，要把id代入，绝对不能一次完成，必须根据推导式，一次一步地代入

  

---

  

#### 重中之重————最左推导和最右推导

  

![最右推导实例](https://i.imgur.com/O3tCalS.png)

  

  

先前演示的例子其实是一个最左推导，而上图演示的是最右推导的例子 两相对比，我们会发现，最左推导，其实就是按照产生式得出式子后，每一次我们都优先替换最左边的非终结符。同理，最右推导就是每次都优先推导最右边的非终结符。

  

  

由上图的推导式得出 E + E后，首先就是把式子最右边的E替换成id，然后从右往左处理

  

**注意，最左推导和最右推导有完全相同的语法树结构**

  

  

![最左推导说明](https://i.imgur.com/ax18kxH.png)

  

如图是一个input string的最左推导，我们需要注意的是，最左推导，其实和二叉树左子树的遍历类似，都是相对的左，也就是当前子树分支的左边，在本图中，S推出aA，A是产生式，而左边的**子树a** 已经终结，那就从**右子树A**的左边开始依次类推

  

  

----

  

#### 二义性问题

  

![二义性问题](https://i.imgur.com/n4pMYE9.png)

  

语法有时会存在二义性，当最左或者最右推导具有一种以上的推导方法(也就是说同一种方向的推导至少有两种不同替换方案)，就说明存在二义性

  

  

![二义性实例](https://i.imgur.com/jFAPHA7.png)

  

图示就是星推导的例子，对于要构建的式子**id*id +id**,同样是最左推导竟然有两种不同的替换方案

  

1. 红色的方案，先有 **E + E**,然后对左边的**E**展开**E * E**,而右边的紫色方案，先有**E * E**,然后对左边的**E**替换成**id**，再处理右边的，这两种方案都是最左推导。

  

2. 正是有两种推导才说明了产生式会导致二义性，并且**这两种二义性产生的语法树在结构上是不同的**

  

  

3. 二义性的产生和使用的非终结符相同有很大的关系，通过替换非终结符，可以一定程度消除二义性问题

  

  

#### 练习

  

![二义性练习](https://i.imgur.com/nfD6kLo.jpeg)

  

如上图就是消除了二义性的新产生式

  

![我的错误答案](https://i.imgur.com/524Bffu.jpeg)

  

以上是我的答案，但是显然它是错的，大体的思路没有错,但是我在画红圈的这步不是最左推导所以错了

  

  

以下是正确解答，这告诉我们，**牢记最左推导很重要,一定要仔细看看左边是否能进一步推导**

  

![正确解答](https://i.imgur.com/0VQ4Rjd.jpeg)

  

  

----

  

  

![一道综合题](https://i.imgur.com/XfVRiPn.jpeg)

  

  

![我的错误答案](https://i.imgur.com/ak2c0Wi.jpeg)

  

不幸的是我再次做错了，第一问回答我就回答错了，我的答案不应该是上下文无关语言，而是要说明语言描述了什么效果

  

应该说是**生成任意嵌套组合的成对匹配的括号串**，并且第三题，我要举一个最左推导的不同构例子例说明二义性

  

![第三题答案](https://i.imgur.com/dwCn2hV.jpeg)

  

![第三题答案](https://i.imgur.com/M89VzCE.jpeg)

  

以上就是两个不同构的最左推导

  

------------------------------------------------------------------------------

  

## 第五章

  

**Top-down parsing**（自顶向下解析）是一种语法解析技术，它从**文法的起始符号**（Start Symbol）开始，逐步尝试匹配输入字符串，按照**文法规则**推导出终结符序列。如果推导出的终结符序列与输入匹配，则解析成功，否则解析失败。

  

### **主要特点**

  

1.  **从起始符号出发**，按规则推导输入字符串，而不是从输入字符串反向构造语法树。

2.  **使用递归或迭代**，按照语法规则展开非终结符。

3.  **适用于LL文法**（Left-to-right, Leftmost derivation，即从左到右扫描输入，采用最左推导）。

  
  

----

#### 以下用一个递归下降解析的实例说明整个流程

![递归下降例子](https://i.imgur.com/MZGXp0S.png)

在上述的两条产生式中有2个非终结符 *E*和*T*, 有5个终结符: *int* 、 *'+'*、 ** * ** 、*'('* 和 *')'*.

正如之前描述的样子递归下降法会从起始符E开始，然后依据产生式，不断尝试递归看是否能产生我们期望的token流

  

>具体匹配机制参见chapter 5 pdf文档

  

![执行过程](https://i.imgur.com/hUvRUTL.png)

这里面有很关键的地方**next指针**，这个指针永远指向token流**(我们从输入读取到的)**中下个字符的位置

以下是next机制的伪代码

``````

TOKEN next; // 指向当前的 token（即将处理的）

  

void match(TOKEN expected) {

if (next == expected) {

next = getNextToken(); // 读取下一个 token

} else {

error("Syntax Error! Unexpected token.");

}

}

``````

  

-----

#### 实现递归下降算法的伪代码

![递归下降例子](https://i.imgur.com/MZGXp0S.png)

![伪代码1](https://i.imgur.com/lYU0SwV.png)

![伪代码2](https://i.imgur.com/2tKWDwm.png)

![伪代码3](https://i.imgur.com/gglvcMr.png)

图的结构不太清晰，其实有几点需要注意:

1. 除了term函数，以上的每个函数均由产生式得来

2. 有*E*和*T*两个非终结符那就会有**E(),T()**这两个函数调用其他由产生式右部得来的函数

3. 一共有五条产生式的右部，那就会有5条相关的函数*E1(),E2(),T1(),T2(),T3()*

4. 在个别产生式右部函数中，函数调用的顺序一定要和产生式的顺序一致

5. 我们在每个调用前都加next = save 如 (next = save, T1()) || (next = save, T2()) || (next = save, T3()),做这些操作是为了每一次如果之前有解析失败，那递归回来后就让next回到开始的起点

  

--------

#### 递归下降解析的缺点

![缺点](https://i.imgur.com/ZpuInIV.png)

1.  **Easy to implement by hand**

-  **翻译**：手动实现起来非常简单。

-  **解释**：递归下降解析器是最容易手工编写的一种解析器，直接用函数对应文法中的非终结符。

2.  **But not completely general**

-  **翻译**：但并不具有普适性。

-  **解释**：递归下降解析器只适用于一定范围的文法（如 LL(1) 文法），不能解析所有形式的文法，尤其是左递归或冲突严重的文法。

3.  **Cannot backtrack once a production is successful**

-  **翻译**：一旦某个产生式匹配成功，就不能再回溯到其他产生式。

-  **解释**：对于**纯 LL(1) 解析**或**没有回溯机制的递归下降**，当某个产生式开始匹配并成功后，解析器就不会回头再尝试其他产生式分支。这意味着文法中**同一个非终结符不应同时有多个产生式都能匹配同样的输入**。

4.  **Works for grammars where at most one production can succeed for a non-terminal**

-  **翻译**：适用于对于每个非终结符，最多只能有一个产生式能够成功匹配的文法。

-  **解释**：这是典型的**LL(1)** 文法特征：在同一个非终结符的所有产生式中，通过查看下一个输入符号就能确定究竟用哪一个产生式，不需要回溯或二次选择。

  

#### 缺点的实例

![](https://i.imgur.com/lAETVDx.png)

两个输入串 int和int*int，则两个输入串都能匹配**T-> int**,但是，对于第二个例子这个匹配显然不对(显然第二个要匹配 T -> int * )，可怕的是，一旦匹配成功了，那不符合也无法再回溯了，这个问题我们称为**左公因子问题**

![左递归锁死](https://i.imgur.com/6FIu5Lg.png)

另一种缺点和左递归，最左推导的特性有关，从上图可以看到，这就是无解的死递归循环

  

**但是左递归有解决的方法**

![解决方法](https://i.imgur.com/HUUQ6yF.png)

**直接套公式，依然画葫芦就可以解决递归问题**

![](https://i.imgur.com/Cd3SHap.png)

**为什么等价**

![](https://i.imgur.com/jQjXOUg.png)

![](https://i.imgur.com/2EMkr7r.png)

细想可知完全等价

  

-------

#### 例题

![](https://i.imgur.com/gAIC8Bb.png)

![](https://i.imgur.com/aLjO9rd.jpeg)

答案

![](https://i.imgur.com/FOFU2Ma.jpeg)

---

#### 自然接下来我们就应该提出解决左公因子的办法
将用到以下的技术，预测分析
![预测分析的内容](https://i.imgur.com/bqCMY1p.png)
其中我认为最重要的，就是预测分析**不会回溯**的特点，这就意味着**对于一个确定的非终结符仅有一条可选的产生式**

![关于LL(1)文法与recursive descent的对比](https://i.imgur.com/DckDP0G.png)
##### 具体有关LL(1) 文法的内容，参见 LL(1)文法.md

----
#### 左公因子的消除
![消除左公因子](https://i.imgur.com/5GM7oQO.png)
以上是消除左公因子的方法 T-> int | int * T,两个式子有相同的左公因子 int 使用一个 Y把 \* T作为一个可递归的情况，根据实际判断是否还要继续下去

我们来看一个实际的例子：
![消除实例](https://i.imgur.com/rWQhZLn.png)
因为LL(1)文法无法解决左递归问题，我们首先需要把式子中的左递归去掉，**注意空的情况一定不能漏掉要特别小心**

--------
**解析表**
![解析表](https://i.imgur.com/Z9S6yn1.png)
以上是一个LL(1)的语法解析表，这个表反应的关键信息是，单个非终结符是没有意思的，只有**[终结符,input_token]组成的二元对**才有意义，我们实际是根据二元对做分析和判断的之后，我们会和栈协同使用反应二元对的作用

##### 表的使用方法
![表的使用方法](https://i.imgur.com/YC193dM.png)
我们根据二元对选择我们的产生式，并且我们设置一个栈连存储语法树的前端，这个栈包括:
1. 还没有被展开的终结符(这意味着终结符展开就要出栈)

2. 还没有被输入匹配到的终结符
3. 栈顶是当前处理的最左的终结或非终结符

**如果我们碰到了输入的结束符且栈已经空了，那么整个串的匹配就结束了， 如果我们碰到错误的状态会被拒绝**


---
栈的模拟
![栈的模拟](https://i.imgur.com/I1aveyI.png)
我们开始的时候，把启动符 *E* 和输入结束符  *\$* 压入栈中，此时  *\$*  在栈底，我们把 *E* 展开,得 TX ，然后 E 出栈，此时根据我们的二元对，我们把 int Y 进栈(这其实也是在进行最左处理)，当int和我们的输入匹配了，就把int出栈，按照以上过程重复，把已展开的，已匹配的出栈，知道 *\$* 到达栈顶


伪代码的实现
![伪代码实现](https://i.imgur.com/qGmyMPW.png)

-------
#### first集与follow集

# Follow 集（Follow Set）详解

## 1. Follow 集的定义

$$
\text{Follow}(X) = \{ t \mid S \Rightarrow^* \beta X t \delta \}
$$

- **含义**：
  - 对于非终结符 \\( X \\)，\\( \text{Follow}(X) \\) 包含所有在某个句型中 **直接跟在 \\( X \\) 后面的终结符 \\( t \\)**。
  - 如果 \\( X \\) 可以出现在句型的末尾，则结束符 `$` 也属于 \\( \text{Follow}(X) \\)。

---

## 2. Follow 集的计算规则

### 规则 1：产生式中的传递关系
**场景**：若存在产生式 \\( A \to \alpha B \beta \\)（\\( B \\) 为非终结符）：

1. **First(β) 加入 Follow(B)**：
   $$
   \text{First}(\beta) \subseteq \text{Follow}(B)
   $$
2. **若 β 可空（\\( \beta \Rightarrow^* \epsilon \\)）**：
   $$
   \text{Follow}(A) \subseteq \text{Follow}(B)
   $$

### 规则 2：起始符号的特殊处理
- 若 \\( S \\) 是起始符号：
  $$
  \$ \in \text{Follow}(S)
  $$

---

## 3. 计算示例

### 给定文法：
\`\`\`
S → E
E → T X
X → + E | ε
T → int | (E)
\`\`\`

### 计算步骤：
1. **初始化**：
   $$
   \text{Follow}(S) = \{ \$ \}
   $$
2. **处理 E → T X**：
   - \\( \text{First}(X) = \{ +, \epsilon \} \subseteq \text{Follow}(T) \\)
   - 因 \\( X \\) 可空，\\( \text{Follow}(E) \subseteq \text{Follow}(T) \\)
3. **处理 T → (E)**：
   - \\( ) \in \text{Follow}(E) \\)
4. **最终结果**：
   $$
   \begin{aligned}
   \text{Follow}(E) &= \{ ), \$ \} \\
   \text{Follow}(T) &= \{ +, ), \$ \} \\
   \text{Follow}(X) &= \{ ), \$ \}
   \end{aligned}
   $$

---

## 4. 为什么需要 Follow 集？

- **LL(1) 分析表**：
  - 当非终结符 \\( A \\) 可空时（\\( A \to \epsilon \\)），需根据 \\( \text{Follow}(A) \\) 决定是否选择该产生式。
  - **冲突检测**：若 \\( \text{First}(A) \cap \text{Follow}(A) \neq \emptyset \\)，则文法非 LL(1)。

---

## 公式渲染说明
GitHub 的 Markdown 原生不支持 LaTeX，但：
- 使用 `$$` 包裹的公式会显示为独立块（如上方示例）。
- 使用 `\\( \\)` 包裹行内公式（如 \\( \text{Follow}(X) \\)）。
- 避免使用 `\\` 换行符（可能无法解析）。

