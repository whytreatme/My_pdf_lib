
  

  

  

  

  

  

## 第二章

  

  

  

  

  

  

  

主要围绕PL/0语言展开

  

  

  

  

  

  

### PL/0语言的特点：

  

  

  

  

  

  

  

1. PL/0语言是混合型语言，类似于java，先由编译器生成的**Pseudo Pcode**，再将Pseudo Pcode交由解释器直接生成结果

  

  

  

  

  

  

2.

  

  

  

  

  

  

![feature](https://i.imgur.com/LLWt09j.png)

  

  

  

  

  

  

如上图所示，PL/0语法有很多特点：变量类型只有整型、 函数嵌套的层级上限是3 、少量的控制语句

  

  

  

  

  

  

  

#### 以上特点的示例

  

  

  

  

  

  

![一个真实的案例](https://i.imgur.com/nJk0Ovh.png)

  

  

  

  

  

  

1. PL/0中没有函数只有过程(*program*)，一个过程由*program*关键字和过程名组成，并且过程类似函数是可以带参数的，如 *PROGRAM add(a,b);* 也是可以的

  

  

  

  

  

  

  

2. 使用 *VAR* 关键字声明整形，因为除了整形就是常量

  

  

  

  

  

  

  

3. 局部变量是非常重要的内容，这直接影响了接下来Pseudo Pcode的编码，图中标注的 *Main Procedure* 拥有 level = 0的层级，观察可以发现 *Procedure P* 和 *Main Procedure* 所定义的变量B,C是处于同一层级的，所以 *Procedure P* 拥有 level = 1的层级，类似，*Procedure Q* 拥有level = 2的层级

  

  

  

  

  

  

4. 在自己的过程 *(Procedure)* 中定义的变量为局部变量，每一个过程拥有使用level更小层级定义的变量的权力，如：*Procedure Q* 可以使用变量D（这是在*Procedure P*中定义的)， *Main Procedure* 可以 调用 *(call)*  *Procedure P*，这个相当于它自己定义的变量一样。

  

  

  

  

  

  

5. 但是level小的层级不能使用level大的层级，这很好理解，就是作用域的范围问题，比如：P < Q 而 main < P 所以main无法调用Q定义的变量

  

  

  

  

  

  

  

### 来个编译后的实例

  

  

  

  

  

  

![instruction set](https://i.imgur.com/5JIf3mV.png)

  

  

  

  

  

  

![编译过的实例](https://i.imgur.com/CMzY4Ib.png)

  

  

  

  

  

  

1. 首先，编译生成的Pseudo Pcode代码顺序 完全等同于源代码的顺序

  

  

  

  

  

  

2. 指令集第一行参数为level_diffrence，它的意义是你所操作的对象和你当前过程的level 差，比如：第三条 lod 1 3，这条语句是对变量b进行取的操作，该过程是 *Procedure p*，但是操作的变量b却是在 *main Procedure*中定义的，所以level_diffrence = 1 - 0 =1，**注意，只有Load取 store存 call调用 这三个过程有level diference**

  

  

  

  

  

  

  

3. 结合指令集观察我们的代码发现，虽然按照顺序编译，但是第一条指令并不直接分配空间，这是一条跳转指令，要求跳转到第8条指令执行，到第2条指令我们才为变量b,c分配了空间

  

  

  

  

  

  

4. opr 0 0，这条语句由上面的指令集可知这是返回调用的命令，相当于return

  

  

  

  

  

  

  

#### 以上值得注意的是，调用过程 *(call)* 是动态的，因为有可能调用是有条件的，只有实际运行时才能决定是否调用，而定义是静态的，编译完就已经固定不变

  

  

  

  

  

  

  

## 第三章

  

  

  

  

  

  

第三章的重点还是词法分析，在本章中我们关注单词的形式化描述，如使用正规式描述一个单词的构成，或者使用有向的状态转换图描述我们的单词

  

  

  

  

  

  

  

以下是一个短句的各部分成分

  

  

  

  

  

  

![如图](https://i.imgur.com/6OSwiZC.png)

  

  

  

  

  

  

  

1.词法分析的目的在于把输入的字符串分割成一个又一个的词语，然后再把每个词语划分token class,如上图所示，一个词可以是关键字，标识符，数字和分隔符

  

  

  

  

  

  

  

2.值得注意的是，有时，我们不能读了一个字符就马上决定它是什么，需要再向前读多一位，因为有可能是一个俩个字符组成的操作符, ** 例如 '<' 和 '<=' **

  

  

  

  

  

  

  

**词法分析的步骤可以用这个流程图来表示**

  

  

  

  

  

  

![词法分析流程图](https://i.imgur.com/ViwBYFN.png)

  

  

  

  

  

  

注意其中有个二分查找的过程，在 Is ID a KEYWORD 中

  

  

  

  

  

  

  

### 正规式

  

  

  

  

  

  

1.基本运算

  

  

  

  

  

  

![正规式的基本操作](https://i.imgur.com/KLQ4pZV.png)

  

  

  

  

  

  

上图是正规式的集中运算 其**主要有三种操作 a | b (或), ab(连接), a*(星闭包) ** ，其中三者的优先级是星闭包>连接>或

  

  

  

  

  

  

  

首先，**ϵ**代表一个空字符串，也就是说匹配到空字符就用这个符号表示，所以空串函数操作后还是空串

  

  

  

  

  

  

  

运算 * A|B * 相当于 一个或运算，说明这个位置有两种可能性既可以是A也可以是B,但是最终只有一种确定的可能性

  

  

  

  

  

  

  

运算AB是一个看不见的隐式调用，读作A连接B，这其实暗含了顺序的特点，即字符A在前，字符B紧跟其后

  

  

  

  

  

  

  

运算A*读作A的星闭包，其意思是可能的集合有**ϵ**, **A**, **AA**, **AAA**.......一直到无穷多个都是有可能的

  

  

  

  

  

  

运算A+读作A的正闭包，它和星闭包唯一的区别就是它不可能是空串

  

  

  

  

  

  

  

**详细展开如图所示**

  

  

  

  

  

  

![详细展开](https://i.imgur.com/dNMC7xm.png)

  

  

  

  

  

  

  

#### 具体详细的中文定义如下

  

  

  

  

  

  

![详细的中文定义](https://i.imgur.com/uH1Q6oj.png)

  

  

  

  

  

  

  

2.详细的例子

  

  

  

  

  

  

![详细的例子](https://i.imgur.com/pXgI7PY.png)

  

  

  

  

  

  

上述正规式我都写了关于串长度的下界，这些下界是有正规式的预算法则决定的，比如第一个ba*，串中肯定有b，但是a*可能是空串到无穷，所以长度至少大于1

  

  

  

  

  

  

  

需要注意的是倒数第一、二个，(aa|ab|ba|bb)*这个输出要么是空串，要么就只会是偶数长度的串

  

  

  

  

  

  

  

倒数第一个(a|b)(a|b)等价于(aa|ab|ba|bb)

  

  

  

  

  

  

  

3.满足的运算律

  

  

  

  

  

  

![满足的运算律](https://i.imgur.com/Zox8sWR.png)

  

  

  

  

  

  

  

#### 例题

  

  

  

  

  

  

![例题](https://i.imgur.com/ZKdST2g.png)

  

  

  

  

  

  

  

要判断三个表达式是否等价，就需要知道他们是不是能处理的串完全相同，可以尝试把三个式子展开

  

  

  

  

  

  

(a|b)* = (a|b)(a|b)(a|b)...(a|b),同理可得其它

  

  

  

  

  

  

  

需要注意优先级的问题，()的优先级最高

  

  

  

  

  

  

第三个 ((**ϵ**|a)b*)，由分配律可得等价于(b*|ab*),展开后可知三者所能实现的串应该是一样的所以三者等价

  

  

  

  

  

  

  

#### 作业

  

  

  

  

  

  

![正则式作业](https://i.imgur.com/UAFsBb4.jpeg)

  

  

  

  

  

  

我的答案显然是错误的，它的确可以表示出任意长度的空串，但**问题是我的答案表示出的不仅仅是任意长度的空串，还包括了空串和长度为偶数的串**，正确答案应该为** (a|b) ( (a|b) (a|b) )* **,在确保里面的串是偶数的情况下，在选择a或b就成了奇数串

  

  

  

  

  

  

  

### 自动机

  

  

  

  

  

  

------

  

  

  

  

  

  

**NFA 有着自身的缺点，比如时间开销过大**所以我们需要将NFA确定化为DFA,这主要是用到两种操作，首先是把**空闭包**(**ϵ**)计算出来，然后在把从一种状态到另一种状态的条件找出来 *move*

  

  

  

  

  

![操作](https://i.imgur.com/T8u9ppv.png)

  

  

  

  

  

1.所谓求空闭包，就是求一个状态经过空串**ϵ**，所能到达的所有状态的集合

  

  

  

  

  

  

2.求move，就是一个包含所有空闭包的集合经过一次条件转换所能达到的空闭包状态集合

  

  

  

  

  

  

#### 空闭包实例

  

  

  

  

  

![实例](https://i.imgur.com/3q1zzU0.png)

  

  

  

  

  

对**B**求空闭包:自身一定包含，**C,D**空串可达

  

  

  

  

  

对**G**求空闭包:到**A**空串可达，**A**可达的也需要包括

  

  

  

  

  

  

#### 实际求解步骤

  

  

  

  

  

![实际求解](https://i.imgur.com/ZZU14eJ.png)

  

  

  

  

  

1. 首先我们要求出关于原NFA初态的空闭包，在以上例子中就是求出**A**的空闭包。

  

  

  

  

  

2. 然后明确有多少个输入，在以上例子中一共就是0,1两种输入，这就是move

  

  

  

  

  

3. 拿着初态空闭包集，判断该集合中每一个状态接受了输入之后会跳转到哪个状态，并且到达该状态后可以由空闭包活得其它的哪些状态，比如空闭包中的**D**接受一个输入0跳转到**F**，而**F**空闭包可以得到**G**,**H**,**I**

  

  

  

  

4. 最后得到的新终态是包含原来终态(在本例中是**J**)的集合，如果原自动机中有多个终态，那只需要包括其中一个终态即可

  

  

  

  

  

  

#### 状态转换图和实现表

  

  

  

  

  

![](https://i.imgur.com/OEzkr2i.png)

  

  

  

  

  

**两个可以互相转换，都要考**


  

以下是一道关于由状态转换图画实现表的例题

  

  

  

  

  

![](https://i.imgur.com/gHF5wbd.png)

  

  

  

  

  

值得注意的一点是多一个或者少一个状态都不是相同的集合

每move一次得到一个集合就添加到纵向的状态栏中
  

**最好每个在状态标记一个字母，这样不容易错**

下面还有一个重要例子
![重要例子](https://i.imgur.com/Bol6Z4J.png)
这道例题告诉我先画表后画图的重要性，单纯画图状态就容易混乱看得不清晰

### 总结
1.先画表，后画图，看表画图
2.找到所有初态用空闭包找
3.找到所有输入
4.用手指着状态一个一个判断接受输入后的状态及其空闭包知道最后一个状态
5.给每一个状态标序号
6.单独列出第1、2、3........序号的状态
7.继续下一个状态

  

  

  

  

  

## 第四章


  

本章讲语法分析，是有关**CFG(上下文无语言)**的章节，CFG是全书的重点内容，是最重要的形式化工具

  

  

  

  

  

#### 前面我们学过了很多的形式化工具，但是无论是正则公式，还是自动机都有其表示的局限性，例如

  

  

  

  

![问题实例](https://i.imgur.com/2HCGTSe.png)

  

  

  

  

以上例子要求表示括号的成对性，但是无论是正则式还是自动机都无法表示括号的成对出现

  

  

  

  

  

而**CFG就是可以控制符号出现次数的语言**

  

  

  

  

  

![](https://i.imgur.com/Pm71OXD.png)

  

  

  

  

在这个例子中，自动机可以确保1出现的次数必定是奇数，但是0的数量无法控制，并且无论是0或1，都无法控制实际出现的次数

  

  

  

  

  

#### 语法分析一定会生成一颗语法树，例如:

  

  

  

  

![语法树](https://i.imgur.com/riCOQSn.png)

  

  

  

  

这就是一颗语法树，当我们把语法框架IF-THEN-ELSE抽离出来，用二元运算符作为语法树的节点

  

  

  

  

  

---

  

  

  

  

![](https://i.imgur.com/bKV6g83.png)

  

  

  

  

递归嵌套的声明是CFG的重要内容，以上例子中，EXPR表达式还可以循环代入，这就是推导*(derivation)*的重要内容

  

  

  

  

  

#### CFG的组成

![组成](https://i.imgur.com/gKerlaJ.png)

  

  

  

  

  

1.终结符集(小写)

  

  

  

  

2.非终结符集(大写)

  

  

  

  

3.开始符

  

  

  

  

4.产生式集

  

  

  

  

  

***其中终结符集不可被替换，非终结符集会被替换，开始符只有一个，我们依赖于产生式集做推导***

  

  

  

  

  

#### 详细(derivation)推导的过程

  

  

  

  

![](https://i.imgur.com/Luwd0jo.png)

  

  

  

  

1.产生式集左边称为左部，右边为右部

  

  

  

  

2.推导过程就是不断使用右部替代左部的过程，直到没有终结符

  

  

  

  

3.归约*(reduction)*是推导的逆过程，就是从结果反推解析产生式

  

  

  

  

![](https://i.imgur.com/QRhIwUT.png)

  

  

  

  

  

![](https://i.imgur.com/81wH0UN.png)

  

  

  

  

我们通过产生式将非终结字符替换成终结字符

  

  

  

  

  

![星推导](https://i.imgur.com/2nQMvUu.png)

  

  

  

  

这个推导可以包含0步到无穷多步的推导，但是一般不常用到

  

  

  

  

  

![推导例子](https://i.imgur.com/JFQRM2W.png)

  

  

  

  

  

![答案](https://i.imgur.com/22E5tRP.png)

  

  

  

  

**注意语法树一定要画，且我们只需把最终成型的树画出即可，不必画出过程，但推导式的过程必须要写完整**

  

  

  

  

非终结式就是可以一直推导下去的部分

  

  

  

  

----

  

  

  

#### 接下来来看一个相当重要的推导实例

  

  

  

![](https://i.imgur.com/QLvio6l.png)

  

  

  

以上是一条产生式和需要达成的最终推导结果

  

  

  

  

![文法推导以及语法树](https://i.imgur.com/pES24L2.png)

  

  

  

以上就是上述题目的文法推导和相应的语法树生成，其中有几点需要**注意**的:

  

  

  

1. 推导式从启动符**(本题是E)**开始，由产生式得出的关系推导

  

  

  

2. 语法树的中每个非叶节点都对应产生式的左部，而它的子节点要对应相应产生式的右部

  

  

  

  

3. 在推导式中任意一个符号(终结与非终结)都必须有它自己的分支，如图中画红圈的**'+'**,哪怕不能继续推导也必须有自己的分支，又如最后是空串 **ϵ**，也要写到语法树中

  

  

  

4. 文法推导**一次只允许做一步操作**，如以上例子，要把id代入，绝对不能一次完成，必须根据推导式，一次一步地代入

  

  

  

---

  

  

  

#### 重中之重————最左推导和最右推导

  

  

  

![最右推导实例](https://i.imgur.com/O3tCalS.png)

  

  

  

  

先前演示的例子其实是一个最左推导，而上图演示的是最右推导的例子 两相对比，我们会发现，最左推导，其实就是按照产生式得出式子后，每一次我们都优先替换最左边的非终结符。同理，最右推导就是每次都优先推导最右边的非终结符。

  

  

  

  

由上图的推导式得出 E + E后，首先就是把式子最右边的E替换成id，然后从右往左处理

  

  

  

**注意，最左推导和最右推导有完全相同的语法树结构**

  

  

  

  

![最左推导说明](https://i.imgur.com/ax18kxH.png)

  

  

  

如图是一个input string的最左推导，我们需要注意的是，最左推导，其实和二叉树左子树的遍历类似，都是相对的左，也就是当前子树分支的左边，在本图中，S推出aA，A是产生式，而左边的**子树a** 已经终结，那就从**右子树A**的左边开始依次类推

  

  

  

  

----

  

  

  

#### 二义性问题

  

  

  

![二义性问题](https://i.imgur.com/n4pMYE9.png)

  

  

  

语法有时会存在二义性，当最左或者最右推导具有一种以上的推导方法(也就是说同一种方向的推导至少有两种不同替换方案)，就说明存在二义性

  

  

  

  

![二义性实例](https://i.imgur.com/jFAPHA7.png)

  

  

  

图示就是星推导的例子，对于要构建的式子**id*id +id**,同样是最左推导竟然有两种不同的替换方案

  

  

  

1. 红色的方案，先有 **E + E**,然后对左边的**E**展开**E * E**,而右边的紫色方案，先有**E * E**,然后对左边的**E**替换成**id**，再处理右边的，这两种方案都是最左推导。

  

  

  

2. 正是有两种推导才说明了产生式会导致二义性，并且**这两种二义性产生的语法树在结构上是不同的**

  

  

  

  

3. 二义性的产生和使用的非终结符相同有很大的关系，通过替换非终结符，可以一定程度消除二义性问题

  

  

  

  

#### 练习

  

  

  

![二义性练习](https://i.imgur.com/nfD6kLo.jpeg)

  

  

  

如上图就是消除了二义性的新产生式

  

  

  

![我的错误答案](https://i.imgur.com/524Bffu.jpeg)

  

  

  

以上是我的答案，但是显然它是错的，大体的思路没有错,但是我在画红圈的这步不是最左推导所以错了

  

  

  

  

以下是正确解答，这告诉我们，**牢记最左推导很重要,一定要仔细看看左边是否能进一步推导**

  

  

  

![正确解答](https://i.imgur.com/0VQ4Rjd.jpeg)

  

  

  

  

----

  

  

  

  

![一道综合题](https://i.imgur.com/XfVRiPn.jpeg)

  

  

  

  

![我的错误答案](https://i.imgur.com/ak2c0Wi.jpeg)

  

  

  

不幸的是我再次做错了，第一问回答我就回答错了，我的答案不应该是上下文无关语言，而是要说明语言描述了什么效果

  

  

  

应该说是**生成任意嵌套组合的成对匹配的括号串**，并且第三题，我要举一个最左推导的不同构例子例说明二义性

  

  

  

![第三题答案](https://i.imgur.com/dwCn2hV.jpeg)

  

  

  

![第三题答案](https://i.imgur.com/M89VzCE.jpeg)

  

  

  

以上就是两个不同构的最左推导

  

  

  

------------------------------------------------------------------------------

  

  

  

## 第五章

  

  

  

**Top-down parsing**（自顶向下解析）是一种语法解析技术，它从**文法的起始符号**（Start Symbol）开始，逐步尝试匹配输入字符串，按照**文法规则**推导出终结符序列。如果推导出的终结符序列与输入匹配，则解析成功，否则解析失败。

  

  

  

### **主要特点**

  

  

  

1.  **从起始符号出发**，按规则推导输入字符串，而不是从输入字符串反向构造语法树。

  

  

2.  **使用递归或迭代**，按照语法规则展开非终结符。

  

  

3.  **适用于LL文法**（Left-to-right, Leftmost derivation，即从左到右扫描输入，采用最左推导）。

  

  

  

----

  

  

#### 以下用一个递归下降解析的实例说明整个流程

  

  

![递归下降例子](https://i.imgur.com/MZGXp0S.png)

  

  

在上述的两条产生式中有2个非终结符 *E*和*T*, 有5个终结符: *int* 、 *'+'*、 ** * ** 、*'('* 和 *')'*.

  

  

正如之前描述的样子递归下降法会从起始符E开始，然后依据产生式，不断尝试递归看是否能产生我们期望的token流

  

  

  

>具体匹配机制参见chapter 5 pdf文档

  

  

  

![执行过程](https://i.imgur.com/hUvRUTL.png)

  

  

这里面有很关键的地方**next指针**，这个指针永远指向token流**(我们从输入读取到的)**中下个字符的位置

  

  

以下是next机制的伪代码

  

  

``````

  

  

TOKEN next; // 指向当前的 token（即将处理的）

  

  

  

void match(TOKEN expected) {

  

  

if (next == expected) {

  

  

next = getNextToken(); // 读取下一个 token

  

  

} else {

  

  

error("Syntax Error! Unexpected token.");

  

  

}

  

  

}

  

  

``````

  

  

  

-----

  

  

#### 实现递归下降算法的伪代码

  

  

![递归下降例子](https://i.imgur.com/MZGXp0S.png)

  

  

![伪代码1](https://i.imgur.com/lYU0SwV.png)

  

  

![伪代码2](https://i.imgur.com/2tKWDwm.png)

  

  

![伪代码3](https://i.imgur.com/gglvcMr.png)

  

  

图的结构不太清晰，其实有几点需要注意:

  

  

1. 除了term函数，以上的每个函数均由产生式得来

  

  

2. 有*E*和*T*两个非终结符那就会有**E(),T()**这两个函数调用其他由产生式右部得来的函数

  

  

3. 一共有五条产生式的右部，那就会有5条相关的函数*E1(),E2(),T1(),T2(),T3()*

  

  

4. 在个别产生式右部函数中，函数调用的顺序一定要和产生式的顺序一致

  

  

5. 我们在每个调用前都加next = save 如 (next = save, T1()) || (next = save, T2()) || (next = save, T3()),做这些操作是为了每一次如果之前有解析失败，那递归回来后就让next回到开始的起点

  

  

  

--------

  

  

#### 递归下降解析的缺点

  

  

![缺点](https://i.imgur.com/ZpuInIV.png)

  

  

1.  **Easy to implement by hand**

  

  

-  **翻译**：手动实现起来非常简单。

  

  

-  **解释**：递归下降解析器是最容易手工编写的一种解析器，直接用函数对应文法中的非终结符。

  

  

2.  **But not completely general**

  

  

-  **翻译**：但并不具有普适性。

  

  

-  **解释**：递归下降解析器只适用于一定范围的文法（如 LL(1) 文法），不能解析所有形式的文法，尤其是左递归或冲突严重的文法。

  

  

3.  **Cannot backtrack once a production is successful**

  

  

-  **翻译**：一旦某个产生式匹配成功，就不能再回溯到其他产生式。

  

  

-  **解释**：对于**纯 LL(1) 解析**或**没有回溯机制的递归下降**，当某个产生式开始匹配并成功后，解析器就不会回头再尝试其他产生式分支。这意味着文法中**同一个非终结符不应同时有多个产生式都能匹配同样的输入**。

  

  

4.  **Works for grammars where at most one production can succeed for a non-terminal**

  

  

-  **翻译**：适用于对于每个非终结符，最多只能有一个产生式能够成功匹配的文法。

  

  

-  **解释**：这是典型的**LL(1)** 文法特征：在同一个非终结符的所有产生式中，通过查看下一个输入符号就能确定究竟用哪一个产生式，不需要回溯或二次选择。

  

  

  

#### 缺点的实例

  

  

![](https://i.imgur.com/lAETVDx.png)

  

  

两个输入串 int和int*int，则两个输入串都能匹配**T-> int**,但是，对于第二个例子这个匹配显然不对(显然第二个要匹配 T -> int * )，可怕的是，一旦匹配成功了，那不符合也无法再回溯了，这个问题我们称为**左公因子问题**

  

  

![左递归锁死](https://i.imgur.com/6FIu5Lg.png)

  

  

另一种缺点和左递归，最左推导的特性有关，从上图可以看到，这就是无解的死递归循环

  

  

  

**但是左递归有解决的方法**

  

  

![解决方法](https://i.imgur.com/HUUQ6yF.png)

  

  

**直接套公式，依然画葫芦就可以解决递归问题**

  

  

![](https://i.imgur.com/Cd3SHap.png)

  

  

**为什么等价**

  

  

![](https://i.imgur.com/jQjXOUg.png)

  

  

![](https://i.imgur.com/2EMkr7r.png)

  

  

细想可知完全等价

  

  

  

-------

  

  

#### 例题

  

  

![](https://i.imgur.com/gAIC8Bb.png)

  

  

![](https://i.imgur.com/aLjO9rd.jpeg)

  

  

答案

  

  

![](https://i.imgur.com/FOFU2Ma.jpeg)

  

  

---

  

  

#### 自然接下来我们就应该提出解决左公因子的办法

  

将用到以下的技术，预测分析

  

![预测分析的内容](https://i.imgur.com/bqCMY1p.png)

  

其中我认为最重要的，就是预测分析**不会回溯**的特点，这就意味着**对于一个确定的非终结符仅有一条可选的产生式**

  

  

![关于LL(1)文法与recursive descent的对比](https://i.imgur.com/DckDP0G.png)

  

##### 具体有关LL(1) 文法的内容，参见 LL(1)文法.md

  

  

----

  

#### 左公因子的消除

  

![消除左公因子](https://i.imgur.com/5GM7oQO.png)

  

以上是消除左公因子的方法 T-> int | int * T,两个式子有相同的左公因子 int 使用一个 Y把 \* T作为一个可递归的情况，根据实际判断是否还要继续下去

  

  

我们来看一个实际的例子：

  

![消除实例](https://i.imgur.com/rWQhZLn.png)

  

因为LL(1)文法无法解决左递归问题，我们首先需要把式子中的左递归去掉，**注意空的情况一定不能漏掉要特别小心**

  

  

--------

  

**LL(1)分析表**

  

![解析表](https://i.imgur.com/Z9S6yn1.png)

  

以上是一个LL(1)的语法解析表，这个表反应的关键信息是，单个非终结符是没有意思的，只有**[终结符,input_token]组成的二元对**才有意义，我们实际是根据二元对做分析和判断之后，结合栈使用反应二元对的预测作用

  

  

##### 表的使用方法

  

![表的使用方法](https://i.imgur.com/YC193dM.png)

  

我们根据二元对选择我们的产生式，并且我们设置一个栈连存储语法树的前端，这个栈包括:

  

1. 还没有被展开的终结符(这意味着终结符展开就要出栈)

  

  

2. 还没有被输入匹配到的终结符

  

3. 栈顶是当前处理的最左的终结或非终结符

  

  

**如果我们碰到了输入的结束符且栈已经空了，那么整个串的匹配就结束了， 如果我们碰到错误的状态会被拒绝**

  

  

---

  

栈的模拟

  

![栈的模拟](https://i.imgur.com/I1aveyI.png)

  

我们开始的时候，把启动符 *E* 和输入结束符 *\$* 压入栈中，此时 *\$* 在栈底，我们把 *E* 展开,得 TX ，然后 E 出栈，此时根据我们的二元对，我们把 int Y 进栈(这其实也是在进行最左处理)，当int和我们的输入匹配了，就把int出栈，按照以上过程重复，把已展开的，已匹配的出栈，知道 *\$* 到达栈顶

  

  

伪代码的实现

  

![伪代码实现](https://i.imgur.com/qGmyMPW.png)

  

  

-------

  

#### first集与follow集

  

  

**First集**

  

这是关于 **First 集（First Set）** 的定义和计算方法的描述，它是编译原理中 LL(1) 语法分析的关键概念，用于确定文法符号（非终结符或符号串）能够推导出的 **首个终结符集合**。以下是逐步解析：

  

  

![](https://i.imgur.com/weivCMk.png)

  

![](https://i.imgur.com/pcv3jvA.png)

  

![](https://i.imgur.com/gXbjbkT.png)

  

### **3. 关键点总结**

  

  

1.  **终结符**：First 集是它自身。

  

2.  **非终结符**：

  

- 遍历所有产生式，收集右侧符号的 First 集。

  

- 若右侧符号可空，需继续检查后续符号。

  

3.  **ϵϵ 的传播**：只有当所有符号可空时，ϵϵ 才加入 First 集。

  

  

------

  

**Follow集**

  

这是关于 **Follow 集（Follow Set）** 的定义和计算规则的说明，它是 LL(1) 语法分析中的另一个核心概念，用于确定非终结符在文法推导中 **可能紧随其后出现的终结符集合**。以下是详细解析：

  

![](https://i.imgur.com/iIVi97C.png)

  

![](https://i.imgur.com/Xc4Q6AC.png)

  

![](https://i.imgur.com/C5PuU37.png)

  

### **关键点说明**

  

  

-  **与 First 集的关系**：

  

- First 集关注 **符号的起始终结符**，Follow 集关注 **符号后的终结符**。

  

-  **空串（ϵ）的影响**：

  

- 若一个非终结符可空，需要将其后的符号传递到前一个非终结符的 Follow 集中（如规则 1.3）。

  

-  **递归传播**：

  

- Follow 集的计算是递归的，需多次遍历产生式直到所有集合不再变化。

  

  

----

  

**First的例子**

  

![](https://i.imgur.com/eOmpjUD.png)

  

  

![](https://i.imgur.com/XpIbcuY.png)

  

  

#### 求Follow 集的技巧

  

  

![](https://i.imgur.com/yl5dXEF.png)

  

  

-----------

  

#### 一个说明First和Follow集的例子

  

![实例](https://i.imgur.com/uniqT72.jpeg)

  

这道题求出first和follow集以及画出LL(1)语法分析图：

  

**First集：**

  

![](https://i.imgur.com/scuVgP7.jpeg)

  

首先在求first集的时候要注意几点：

  

1. 遇到或** | **要格外注意，因为很容易就会漏掉一种情况

  

2. 遇到空的情况要及其小心，这个时候就要考虑first集的规则2和规则3，以下用first(S)作为示范

  

  

First(S)的产生式S -> MH | a由两部分组成，我们知道本质上first集就是让解析器可以知道我们这条式子展开之后会遇到的第一个字符是什么，从而实现predict，那么我们两部分都要考虑进去，所以集合中肯定有**a**,接下来处理first(MH) = first(M),M -> K | bLM也由两部分组成，自然把**b**加入集合，我还要继续处理K,因为我们不知道处理到最后是否可以推导出空，如果是，那么空**ϵ**也可加入到集合中，**K**出现了空和**d**,那么我们要回退到first(MH)去处理**H**,因为最后一个字符H可以为空，所以空存在集合中。**需要注意的是这部分极其极其容易出错，我们之所以要寻找空是否在集合中是因为分析表需要用到，并且不把所有可能出现的展开找齐，那就会出现预测失败**

  

  

**follow集**

  

![](https://i.imgur.com/ZA2lzDz.jpeg)

  

求follow集合比first集合更加困难，它也有需要注意的地方：

  

1. 启动符的follow集必须包含输入结束符**$**，可以说是没有为什么，但是也可以解释为只有包含输入结束符才认为一个输入可以合法结束

  

2. 对于其它非终结符，关键一点是一定要遍历所有包含该符的产生

  

式的右部

  

3. 规则的应用十分重要

  

  

**我们知道follow集的本质是告诉解析器当前遇到什么样的输入可以跳过当前非终结符**

  

以上述图片最复杂的follow(L)为例，H -> LSo | ε (1)，K -> dML | ε (2)，M -> K | bLM (3)这三条就是包含L的式子，注意L只是出现在式子的右部，左部不算。分析（1）直接和L相接的是S，所以说当遇到S展开的first集就知道当前可以跳过，所以first(S) - ε加入集合，我么还要考虑是否S为空的情况，本例是可以的，所以**o**将和L直接相接，加入结合中，（2）直接应用follow集合的传递性即可，(3)要考虑First(M) - ε和follow(M)的情况 **注意只有终结符能出现在一条产生式的结尾才具有传递性**

  

  

![](https://i.imgur.com/hBJjJzi.jpeg)

  

上图是我根据以上题目填出的分析表，填表也是存在技巧的：

  

1. 先从First集中寻找，在对应的终结符下面选出正确的式子，可以展开直接得到所需的终结符

  

2. 如果该非终结符可以推出空，就要使用到follow集，在对应的非终结符下选取正确的式子

  

3. 注意所出现的式子必须是原来产生式中所有的，并且如果一条式子无法推导出空，则不需要考虑到follow集

  

  

**假设S-> a | b , 因为first(a)与firsr(b)的交集为空，所以不存在a,b能同时推出空的情况**

  

-------------------------------------------------------------------------------



## 第六章(自底向上的语法分析)
![首要条件](https://i.imgur.com/gTIWX3p.png)
自底向上的语法分析，必须是最右推导


![具体解释](https://i.imgur.com/5rpAMSu.png)
上图解释了为什么是最右推导，实际上归约过程可以看作推导的逆过程，从这个角度看，** id  *  id ** 归约为 ** F * id**,从推导的角度看就是最右部分已经处理好


#### Pattern和Sentence
![pattern和sentence](https://i.imgur.com/kmiYRBX.png)
![pattern和sentence的实例](https://i.imgur.com/6wEAApg.png)

**sentence(句子)** 是指能由文法的 **起始符号** 通过一系列合法推导，**最终生成的全为终结符** 的字符串

我们不讨论pattern因为pattern并不是一个确切的术语
![术语表](https://i.imgur.com/fJwlCI3.png)
1.  **句柄的组成**：
    
    -   句柄可以包含**终结符、非终结符或它们的混合**，具体取决于产生式右部  β  的形式。  
        例如，若产生式是  A→aBc（其中  a  是终结符，B  是非终结符），则句柄可能是子串  aBc。
        
2.  **句柄的核心性质**：
    
    -   句柄**必须严格对应某个产生式的右部  β**，且该产生式  A→β  能用于逆向归约（即替换后得到上一个最右句型）。
        
    -   它是当前句型中**最左的可归约子串**，且归约后符合最右推导的逆过程。

#### 具体例子
一下是id * id在归约过程中的句柄变化
![实例](https://i.imgur.com/8IaM6sz.png)

接下来来看看其它的相关概念，我们用一个实例来解释相关概念
![](https://i.imgur.com/ucK2Yl3.png)
上图出现了三个概念: **短语（phrase）**, **直接短语（immediate phrase）**, **句柄（handle）**
关于句柄的概念我们已经有所了解，接下来看短语的概念：
![短语概念](https://i.imgur.com/PLYTj8M.png)
又有
![概念2](https://i.imgur.com/biSGBZo.png)
关于直接短语：
![直接短语概念](https://i.imgur.com/XYEBClK.png)
直接短语和短语之间只是对应的子串是否是非终结符A一步推导得出，它们之间存在以下关系
![关系](https://i.imgur.com/xFFWfjM.png)


有了以上概念，我们来重新看看题目
![](https://i.imgur.com/ucK2Yl3.png)
上图给出了一个句子 i * i + i, 之所以是句子是因为它是由启动符**E**经过任意多步推导得到的，只包含终结符的串。是句子就一定是句型，那根据给出的文法，来看看它的短语有哪些：
i1 * i2 + i3, i1*i2, i1, i2, i3（为了区分清楚给相同元素加了下标）

直观上总结规律，短语就是这颗语法树内部节点(非叶子节点，且子树包含所有叶子)所对应的所有叶子节点构成的子串集合。比如:**E**就是一个内部节点，同时也是树的根节点，它的短语是 i1 * i2 + i3, **F**（最右边的那个）也是内部节点，对应短语是 i3。我在图中画了圈的就是把内部节点和它们对应的子树圈了起来

从数学定义的角度 i1 * i2 + i3 整一个可以看成是由非终结符**E**(也是启动符)经过任意推导得来的，所以是短语，i1 * i2可以看成是 串 T + i3(注意这里是最右推导,T前面可以是空串，+ i3是终结符串)经过任意多步得到的，依次类推i1那是由F * i2 + i3一步得到的，i3是由E + T 多步或者 E + F一步得到的

这样直接短语的概念就更加简单，表现出来就是找高度为2，包含叶子节点的子树
句柄就是最左边的直接短语（要符合最右推导)

看下图的一个例子
![例子2](https://i.imgur.com/u7YPMM2.png)
在这棵语法树中，显然我们给出的句型是 (T + T) * i, 句柄找最左边，那为什么不是 (  而是T呢？( 不也是高度为2且再更左边吗？，这是因为 ( 无法单独归约出一个非终结符。

一道例题：
一个上下文无关文法CFG生成句子abbaa
![](https://i.imgur.com/ygxySMS.jpeg)
![](https://i.imgur.com/yycgIDA.jpeg)
（2）略
（3）
![下标元素](https://i.imgur.com/TxN4QcR.jpeg)
短语: a1 ϵb1b2a2a3, a1,  ϵ,  b1, b2, b1b2, a2, a2a3
直接短语: a1,  ϵ, b1, b2, a2,
句柄: a1

下面来看移进归约分析：
![移进归约的内容](https://i.imgur.com/nTfVx28.png)
在**移进-归约（shift-reduce）**分析过程中：  
**句柄（handle）只会出现在分析栈的栈顶，而不会隐藏在栈的内部。**
1.  **为什么句柄不会出现在栈内部？**
    
    -   如果句柄隐藏在栈内部，说明存在更早的可归约子串未被处理，这与**最左归约**的规则矛盾。
        
    -   **反例验证**：假设句柄  β  隐藏在栈中（如栈内符号为  αβγ），则必须先归约  β，否则无法保证归约顺序与最右推导的逆序一致。

#### 活前缀问题(可行前缀)
![描述](https://i.imgur.com/QYkOvBp.png)
我们没有高效的找出所有句柄的方法，这也是**Viable Prefixes（活前缀又名可行前缀）**存在的意义
我们每次移进或者归约能看到的只有栈中的内容，并不能从整个输入来观察，活前缀只是其中的一个局部可行的解析方式

![](https://i.imgur.com/ES62nNN.png)
### **1. 可行前缀不超出句柄的右边界**

-   **核心含义**：  
    可行前缀  α  只能是句柄  β  的**前缀**（即  α  是  β 的开头部分），而不会包含句柄之后的符号。
    
-   **例子**：  
    若句柄是  β=ab，则可行前缀可能是  ϵ、a，但不会是  abx（因为  x  超出句柄范围）。
    
-   **意义**：  
    保证分析器在归约时只需关注栈顶的有限符号，无需回溯。
    

----------

### **2. 可行前缀是句柄的前缀**

-   **数学表达**：  
    若  β  是句柄，则任何  α 满足  α  是  β  的前缀（即  β=αγ），都是可行前缀。
    
-   **动态性**：  
    随着移进操作的进行，可行前缀逐步扩展，直到完整匹配某个产生式右部（即成为句柄）。
    
-   **示例**：  
    对产生式  A→abc，可行前缀依次为  ϵ、a、ab、abc（最后一步  abc  是句柄）。
    

----------

### **3. 可行前缀存在意味着无语法错误**

-   **关键性质**：  
    只要分析栈中的符号串构成可行前缀，说明当前分析路径**仍可能合法**（即使尚未看到完整句柄）。
    
-   **错误检测**：  
    若栈内符号无法匹配任何可行前缀（如出现非法符号组合），则立即报错。
    
-   **意义**：  
    提供了一种**实时验证**机制，避免无效的移进或归约。

### items（项目）
![项目的移动](https://i.imgur.com/sMh3FvS.png)
   项目就在产生式的右部加“·”用来标记进度
**项目是LR分析的核心工具**，通过“·”的位置跟踪语法规则的匹配进度。
“·”后面是非终结符的称为移进项目，这意味着我们需要将当前输入的非终结符压入栈中
“·”后面是终结符的称为待归约项目，这意味着我们需要递归(goto)E的产生式尝试接下来的输入是否可以归约为E
当“·”到达产生式的尽头，称为归约项目，这意味着，句柄已经完全暴漏，我们可以将栈中的元素归约为产生式的左部
除此之外图中还标注了两个特殊的项目，分别是开始状态 和 接受状态 **(acc)**
![](https://i.imgur.com/QTjjMzp.png)
特殊的，空串永远是归约状态

![多层前缀关系](https://i.imgur.com/bSYeO2s.png)
图中描述了一个比较常见的情形，即栈中包含了多个产生式右部的部分前缀，并描述了它们之间的关系:
### **1. 核心概念：多层前缀（Prefixes）**

-   **栈的组成**：  
    分析栈中的符号可视为多个产生式右部的**嵌套前缀**，形式为：
    
    Prefix1 Prefix2 … Prefixn
    
    每个  Prefixi​  是某个产生式右部  αi 的部分匹配（即  αi 的前缀）。
    
-   **前缀的归约目标**：  
    每个  Prefixi 最终会归约为对应的非终结符  Xi（即  Xi→αi  的左部）。
    

----------

### **2. 前缀间的递归关系**

-   **层级依赖**：
    
    -   Prefixi  的缺失部分（即  αi 未匹配的部分）以  Xi+1​  开头。
        
    -   即存在产生式  Xi−1→Prefixi−1Xiβ，表明  Prefixi归约后的  Xi​  将填补上层前缀  Prefixi−1  的缺失。
        
-   **递归归约**：  
    从最内层  Prefixn 开始归约，逐步向外层传递，直到所有前缀归约为  X1（通常为文法起始符号）。

#### 以下是实际的例子说明
![](https://i.imgur.com/lqwBdl5.png)
![](https://i.imgur.com/7VcQ3hH.png)

#### 在经过上面的准备阶段后，我们可以来实现项目的自动机了
![项目的自动机](https://i.imgur.com/9pOSRUQ.png)
1）首先我们要明确产生式，以及启动符
2）第一个状态永远都是从启动符开始的，我们把“·”加在E的前面，这是我们第一个要归约的终结符，或者说我们期望可以归约的终结符
3）当遇到待归约项目时，我们要把待归约的终结符展开，以便我们读取输入的时候可以成功归约。
4）每一个输入都是一个状态转移的条件，帮助我们跳转到下一个状态，直到项目可以归约

**可能会存在状态的星闭包的情况，也就是接受输入又回到原来的状态**
![](https://i.imgur.com/YdqsUCQ.png)
图示就是这样一个状态，可以接受无数个 (

再看一个具体的例子
产生式集
![](https://i.imgur.com/mMNH0iP.png)
首先扩展产生式集，添加一个接受态，即状态1。这意味着归约已经到了启动符
![](https://i.imgur.com/NTl2MdY.png)
LR(0)分析表由action和goto两部分组成，action接受终结符，goto接收非终结符非终结符，图中的rn(n = 1, 2, 3 ,4)为归约到哪条产生式，goto表的作用其实要配合栈一起使用
![](https://i.imgur.com/W2pkrXq.png)

使用以上分析表判断某个串是否可以归约
![](https://i.imgur.com/FoBvsxh.png)
对应的栈变化如下:
![](https://i.imgur.com/dGG6JWV.jpeg)
**Status**栈和**Lable**栈的变化要同步，每接受一个输入就要查对应的parsing table，看是移进到 下一个状态，还是归约到某个产生式，一旦归约到某个产生式，就要按照对应的规则把终结符和终结符组成的对应串出**Lable**栈，**Status**栈要跟着一起把对应的状态出栈，然后把归约的非终结符入栈置于栈顶(**Lable**),然后根据此时两个栈栈顶的元素，查表，看看应该把哪个状态入栈，如此循环直到遇到接受态(**acc**)

#### LR(0)分析不是万能的有时候也会遇到有冲突的时候，比如：
![LR(0)冲突](https://i.imgur.com/LVVe7hV.png)
图中列举了两种冲突，一种是reduce/reduce冲突（归约-归约冲突），另一种是shift/reduce冲突（移进-归约冲突） 问题的产生本质上是因为LR(0)只能看到当前的一步，不具有前瞻性造成的

我们使用SLR(simple LR)分析来解决问题
![](https://i.imgur.com/BgsvoNt.png)
我们需要知道下一个输入是什么，如果下一个输入出现在可归约终结符**X**的follow集中，意味着不能再移进必须规约，但如果出现在可移进字符集中则移进

再来看个具体的例子:
![](https://i.imgur.com/n8IvzFT.png)
给定产生式，让我们判断是LR(0)还是SLR(1)语法
![](https://i.imgur.com/rk9twnl.jpeg)
在里面找到了归约-移进冲突,有冲突的部分对可移进项目求follow集用来和下一个输入做对比，看看是归约还是移进
![](https://i.imgur.com/Y6Tu6zF.jpeg)
做分析表的要点:
1)对于每一个状态，仔细看准出边，也就是本状态指向下一个状态的边
2）对于可归约的项主义不要写到goto表中，只在action表中标注
3）仔细不要漏状态，每个状态要仔细看输入，特别是follow集部分

### **为什么归约动作不写入goto表？**

-   **goto表的用途**：  
    goto表仅在归约动作完成后使用。当分析器执行归约动作（如按产生式`A → α`归约）时，它会从栈中弹出`|α|`个状态，然后根据**归约后的栈顶状态**和**非终结符A**查询goto表，决定下一步转移到哪个状态。
    
    -   例如：如果归约后栈顶是状态`s`，且归约出`A`，则转移到`goto[s, A]`。
        
-   **归约动作的触发条件**：  
    归约动作的触发依赖于**向前看符号**（终结符），而goto表的键是**非终结符**。因此：
    
    -   归约动作需要根据终结符（如`a`）选择，所以必须写入`action[s, a]`。
        
    -   goto表不涉及向前看符号，仅用于非终结符的状态转移。
        

----------

### 3.  **关键区别**

-   **action表**：处理**终结符**（移进或归约）。
    
-   **goto表**：处理**非终结符**（状态转移）。
    

如果强行将归约动作写入goto表，会导致以下问题：

1.  **无法匹配向前看符号**：goto表的键是`(状态, 非终结符)`，而归约需要`(状态, 终结符)`。
    
2.  **冲突与混淆**：goto表仅用于状态转移，而归约是动作，两者逻辑不同。

#### 另一个例子
![](https://i.imgur.com/OjH6Kwg.png)
一样的套路画DFA，然后画分析表，需要注意的是在这个题目中有一个点是终结符，很容易和归约时的点弄混，且容易漏掉
![](https://i.imgur.com/HbmhirO.jpeg)
在这个图中没有移进-归约冲突，所以只是单纯的LR(0)分析












  

## 第七章 (语义分析和中间代码生成)

  

![静态语义分析与动态语义分析](https://i.imgur.com/Od6ltVP.png)

这张图片的内容是关于 **编程语言编译过程中的语义分析（Semantic Analysis）**，分为 **静态语义分析（Static Semantic Analysis）** 和 **动态语义分析（Dynamic Semantic Analysis）** 两部分。以下是详细解析：

  

---

  

### **1. 静态语义分析（Static Semantic Analysis）**

在编译的语法分析（Syntax Analysis）之后进行，检查程序是否符合语言定义的**静态规则**（不运行程序即可发现的错误）。主要包括：

-  **类型检查（Type Check）**

验证变量、表达式是否类型兼容（如 `int x = "hello";` 会报错）。

-  **控制流检查（Control Flow Check）**

确保程序流程合法（如 `break` 必须在循环内，函数是否有返回值）。

-  **一致性检查（Consistency Check）**

检查变量声明、函数调用是否一致（如未声明的变量、函数参数不匹配）。

-  **名称关联检查（Related Name Check）**

解决变量、函数名的引用关系（如避免命名冲突）。

-  **标识符作用域分析（Scope Analysis of Identifiers）**

确定变量/函数的作用域范围（如局部变量 vs 全局变量）。

  

---

  

### **2. 动态语义分析（Dynamic Semantic Analysis）**

在程序运行时（或中间代码生成阶段）进行的检查，通常涉及：

-  **生成中间代码或目标代码（Generate Intermediate Code or Object Code）**

将符合语义的代码转换为更低级的表示（如三地址码、字节码），为后续优化和机器码生成做准备。

动态语义错误可能在此阶段暴露（如数组越界、除零错误，取决于语言设计）。

  

---

  

### **图示总结**

| **阶段** | **主要任务** | **示例错误** |

|------------------------|-----------------------------------------------------------------------------|---------------------------------------|

| **静态语义分析** | 检查类型、控制流、作用域等编译时可确定的规则。 | 类型不匹配、未声明变量、缺少返回值。 |

| **动态语义分析** | 生成中间/目标代码，处理需运行时才能发现的语义问题（部分语言在此阶段报错）。 | 数组越界、空指针访问、除零错误。 |

  

---

  

### **为什么需要语义分析？**

-  **静态分析**：在编译阶段捕获明显错误，减少运行时崩溃。

-  **动态分析**：处理依赖运行时数据的逻辑（如动态类型语言的部分检查）。

  

---

  

### **扩展知识**

-  **静态语义** vs **动态语义**：

- 静态语义错误（如类型错误）由编译器直接报错。

- 动态语义错误（如越界访问）可能导致运行时异常。

-  **工具应用**：

静态分析工具（如 ESLint、Clang Static Analyzer）可提前发现潜在问题。

  

![中间代码生成](https://i.imgur.com/IZL4RH2.png)

1. triple code(三地址码)

2. Reverse polish notation(逆波兰式)

3. Quad Code(四地址码)

  
  
  
  
  
  
  
  
  
  
  
  

-------------------------------------------------------------------------------

## 第八章

![](https://i.imgur.com/cSA7XKp.png)

##### 本章的章节名翻译过来叫做运行时存储组织

**注意，在plo编译器的代码中，有三个重要的结构体，分别是符号表table,目标代码Code,运行期栈S**

编译器与运行期详细区别见文档编译器与运行期.md

  
  

![运行时的绑定](https://i.imgur.com/30bz8f1.png)

-  **运行时环境**（Running-Time Environment）指的是程序在执行时的环境，它包含了两个关键组成部分：

-  **环境**（Environment）：存储与程序中的名称（如变量名、函数名）相关的信息。

-  **状态**（State）：存储程序中当前的数据（如变量值等）。

-  **绑定（Binding）**：在程序执行过程中，程序中的**名称**与**存储**单元之间的关系被建立。这一过程包括：

-  **name（名称）**：如变量名等。

-  **storage（存储）**：与该名称对应的内存位置。

-  **value（值）**：存储在指定位置的数据。

-  **存储区域**（Storage Area）：在程序执行期间，存储区域包含了多个部分：

-  **Object code**：对象代码，即编译后的机器代码。

-  **Static data**：静态数据，程序的静态部分数据。

-  **Stack**：栈区域，用于存储局部变量和函数调用等。

-  **Heap**：堆区域，用于动态内存分配。

-  **其他存储单位**：

-  **User defined variables and constants**：用户定义的变量和常量。

-  **Temporary work unit**：临时工作单元。

-  **Connection unit required for calling procedure**：调用过程时所需的连接单元。

-  **Input/output buffer**：输入/输出缓冲区。

  
  
  

![AR](https://i.imgur.com/zEf9QPP.png)

AR (Procedure Active Record，过程活动记录), **栈存储分配**（Stack storage allocation）

每当程序**进入一个过程**（即调用一个函数），程序会在栈的顶部分配一个新的**AR**。AR会包含与当前函数调用相关的所有信息，比如：

  

- 局部变量

- 临时变量

- 返回地址

- 参数

- 返回值

- 静态链和动态链等（用于管理作用域和函数调用的关系）。

  

这个AR的目的是为了解决函数调用时需要存储的各类数据，确保函数调用完毕后能够正确返回。

  

我们使用栈结构来保存运行时的程序信息，而AR就是组成栈的基本单位，当调用出现，被调用的过程(*Procedure*)就会生成对应的AR压入栈顶，当该过程返回的时候，AR就会出栈

  
  
  
  
  
  
  
  
  
  

![AR与栈](https://i.imgur.com/ul8Wv5H.png)

在本图中可以知道，一个存储一个过程的空间由 3 + x决定，这个3就是DL(动态链),SL(静态链),RA(返回地址), x就是定义的局部变量的大小

  

![](https://i.imgur.com/q8qmTQz.png)

**SL指向了定义它的过程，DL指向了调用它的过程**

  

![](https://i.imgur.com/1Fn95og.png)

结构非常清晰，一个过程以begin开始，以end结束，根据call (调用)的顺序画出了调用表

  

![](https://i.imgur.com/0hH6ECW.png)

指针sp指向的是当前栈顶AR的基址，也就是SL部分，**DL部分存着栈顶过程的调用程序的的基址(SL)**，之所以需要DL部分是为了方便出栈考虑，当调用结束后，top指针指向原来sp - 1的位置，sp则指向DL存储的地址，这样一个过程就算出栈了。**SL部分存着父栈帧的地址**，SL存在的意义是当需要调用非局部变量的时候，可以根据父栈帧找到该变量初始定义的地方，需要注意的是**有时候我们需要的变量有可能还要在上一层，也就是找到父栈帧的父栈帧**

  

##### 练习

![](https://i.imgur.com/MG43Py6.png)

  

我开始的想法(未评讲)

![](https://i.imgur.com/A1f8uMS.png)