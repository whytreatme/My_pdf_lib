
  

## 第二章

  

  

主要围绕PL/0语言展开

  

### PL/0语言的特点：

  

  

1. PL/0语言是混合型语言，类似于java，先由编译器生成的**Pseudo Pcode**，再将Pseudo Pcode交由解释器直接生成结果

  

2.

  

![feature](https://i.imgur.com/LLWt09j.png)

  

如上图所示，PL/0语法有很多特点：变量类型只有整型、 函数嵌套的层级上限是3 、少量的控制语句

  

  

#### 以上特点的示例

  

![一个真实的案例](https://i.imgur.com/nJk0Ovh.png)

  

1. PL/0中没有函数只有过程(*program*)，一个过程由*program*关键字和过程名组成，并且过程类似函数是可以带参数的，如 *PROGRAM add(a,b);* 也是可以的

  

  

2. 使用 *VAR* 关键字声明整形，因为除了整形就是常量

  

  

3. 局部变量是非常重要的内容，这直接影响了接下来Pseudo Pcode的编码，图中标注的 *Main Procedure* 拥有 level = 0的层级，观察可以发现 *Procedure P* 和 *Main Procedure* 所定义的变量B,C是处于同一层级的，所以 *Procedure P* 拥有 level = 1的层级，类似，*Procedure Q* 拥有level = 2的层级

  

4. 在自己的过程 *(Procedure)* 中定义的变量为局部变量，每一个过程拥有使用level更小层级定义的变量的权力，如：*Procedure Q* 可以使用变量D（这是在*Procedure P*中定义的)， *Main Procedure* 可以 调用 *(call)*  *Procedure P*，这个相当于它自己定义的变量一样。

  

5. 但是level小的层级不能使用level大的层级，这很好理解，就是作用域的范围问题，比如：P < Q 而 main < P 所以main无法调用Q定义的变量

  

  

### 来个编译后的实例

  

![instruction set](https://i.imgur.com/5JIf3mV.png)

  

![编译过的实例](https://i.imgur.com/CMzY4Ib.png)

  

1. 首先，编译生成的Pseudo Pcode代码顺序 完全等同于源代码的顺序

  

2. 指令集第一行参数为level_diffrence，它的意义是你所操作的对象和你当前过程的level 差，比如：第三条 lod 1 3，这条语句是对变量b进行取的操作，该过程是 *Procedure p*，但是操作的变量b却是在 *main Procedure*中定义的，所以level_diffrence = 1 - 0 =1，**注意，只有Load取 store存 call调用 这三个过程有level diference**

  

  

3. 结合指令集观察我们的代码发现，虽然按照顺序编译，但是第一条指令并不直接分配空间，这是一条跳转指令，要求跳转到第8条指令执行，到第2条指令我们才为变量b,c分配了空间

  

4. opr 0 0，这条语句由上面的指令集可知这是返回调用的命令，相当于return

  

  

#### 以上值得注意的是，调用过程 *(call)* 是动态的，因为有可能调用是有条件的，只有实际运行时才能决定是否调用，而定义是静态的，编译完就已经固定不变

  

  

## 第三章

  

第三章的重点还是词法分析，在本章中我们关注单词的形式化描述，如使用正规式描述一个单词的构成，或者使用有向的状态转换图描述我们的单词

  

  

以下是一个短句的各部分成分

  

![如图](https://i.imgur.com/6OSwiZC.png)

  

  

1.词法分析的目的在于把输入的字符串分割成一个又一个的词语，然后再把每个词语划分token class,如上图所示，一个词可以是关键字，标识符，数字和分隔符

  

  

2.值得注意的是，有时，我们不能读了一个字符就马上决定它是什么，需要再向前读多一位，因为有可能是一个俩个字符组成的操作符, ** 例如 '<' 和 '<=' **

  

  

**词法分析的步骤可以用这个流程图来表示**

  

![词法分析流程图](https://i.imgur.com/ViwBYFN.png)

  

注意其中有个二分查找的过程，在 Is ID a KEYWORD 中

  

  

### 正规式

  

1.基本运算

  

![正规式的基本操作](https://i.imgur.com/KLQ4pZV.png)

  

上图是正规式的集中运算 其**主要有三种操作 a | b (或), ab(连接), a*(星闭包) ** ，其中三者的优先级是星闭包>连接>或

  

  

首先，**ϵ**代表一个空字符串，也就是说匹配到空字符就用这个符号表示，所以空串函数操作后还是空串

  

  

运算 * A|B * 相当于 一个或运算，说明这个位置有两种可能性既可以是A也可以是B,但是最终只有一种确定的可能性

  

  

运算AB是一个看不见的隐式调用，读作A连接B，这其实暗含了顺序的特点，即字符A在前，字符B紧跟其后

  

  

运算A*读作A的星闭包，其意思是可能的集合有**ϵ**, **A**, **AA**, **AAA**.......一直到无穷多个都是有可能的

  

运算A+读作A的正闭包，它和星闭包唯一的区别就是它不可能是空串

  

  

**详细展开如图所示**

  

![详细展开](https://i.imgur.com/dNMC7xm.png)

  

  

#### 具体详细的中文定义如下

  

![详细的中文定义](https://i.imgur.com/uH1Q6oj.png)

  

  

2.详细的例子

  

![详细的例子](https://i.imgur.com/pXgI7PY.png)

  

上述正规式我都写了关于串长度的下界，这些下界是有正规式的预算法则决定的，比如第一个ba*，串中肯定有b，但是a*可能是空串到无穷，所以长度至少大于1

  

  

需要注意的是倒数第一、二个，(aa|ab|ba|bb)*这个输出要么是空串，要么就只会是偶数长度的串

  

  

倒数第一个(a|b)(a|b)等价于(aa|ab|ba|bb)

  

  

3.满足的运算律

  

![满足的运算律](https://i.imgur.com/Zox8sWR.png)

  

  

#### 例题

  

![例题](https://i.imgur.com/ZKdST2g.png)

  

  

要判断三个表达式是否等价，就需要知道他们是不是能处理的串完全相同，可以尝试把三个式子展开

  

(a|b)* = (a|b)(a|b)(a|b)...(a|b),同理可得其它

  

  

需要注意优先级的问题，()的优先级最高

  

第三个 ((**ϵ**|a)b*)，由分配律可得等价于(b*|ab*),展开后可知三者所能实现的串应该是一样的所以三者等价

  

  

#### 作业

  

![正则式作业](https://i.imgur.com/UAFsBb4.jpeg)

  

我的答案显然是错误的，它的确可以表示出任意长度的空串，但**问题是我的答案表示出的不仅仅是任意长度的空串，还包括了空串和长度为偶数的串**，正确答案应该为** (a|b) ( (a|b) (a|b) )* **,在确保里面的串是偶数的情况下，在选择a或b就成了奇数串

  

  

### 自动机

  

------

  

**NFA 有着自身的缺点，比如时间开销过大**所以我们需要将NFA确定化为DFA,这主要是用到两种操作，首先是把**空闭包**(**ϵ**)计算出来，然后在把从一种状态到另一种状态的条件找出来 *move*

![操作](https://i.imgur.com/T8u9ppv.png)

1.所谓求空闭包，就是求一个状态经过空串**ϵ**，所能到达的所有状态的集合

  

2.求move，就是一个包含所有空闭包的集合经过一次条件转换所能达到的空闭包状态集合

  

#### 空闭包实例

![实例](https://i.imgur.com/3q1zzU0.png)

对**B**求空闭包:自身一定包含，**C,D**空串可达

对**G**求空闭包:到**A**空串可达，**A**可达的也需要包括

  

#### 实际求解步骤

![实际求解](https://i.imgur.com/ZZU14eJ.png)

1. 首先我们要求出关于原NFA初态的空闭包，在以上例子中就是求出**A**的空闭包。

2. 然后明确有多少个输入，在以上例子中一共就是0,1两种输入，这就是move

3. 拿着初态空闭包集，判断该集合中每一个状态接受了输入之后会跳转到哪个状态，并且到达该状态后可以由空闭包活得其它的哪些状态，比如空闭包中的**D**接受一个输入0跳转到**F**，而**F**空闭包可以得到**G**,**H**,**I**
4. 最后得到的新终态是包含原来终态(在本例中是**J**)的集合，如果原自动机中有多个终态，那只需要包括其中一个终态即可

  
  

#### 状态转换图和实现表

![](https://i.imgur.com/OEzkr2i.png)

**两个可以互相转换，都要考**

  

以下是一道关于由状态转换图画实现表的例题

![](https://i.imgur.com/gHF5wbd.png)

值得注意的一点是多一个或者少一个状态都不是相同的集合

每move一次得到一个集合就添加到纵向的状态栏中

**最好每个在状态标记一个字母，这样不容易错**

## 第四章
本章讲语法分析，是有关**CFG(上下文无语言)**的章节，CFG是全书的重点内容，是最重要的形式化工具

#### 前面我们学过了很多的形式化工具，但是无论是正则公式，还是自动机都有其表示的局限性，例如
![问题实例](https://i.imgur.com/2HCGTSe.png)
以上例子要求表示括号的成对性，但是无论是正则式还是自动机都无法表示括号的成对出现

而**CFG就是可以控制出现次数的语言**

![](https://i.imgur.com/Pm71OXD.png)
在这个例子中，自动机可以确保1出现的次数必定是奇数，但是0的数量无法控制，并且无论是0或1，都无法控制实际出现的次数

#### 语法分析一定会生成一颗语法树，例如:
![语法树](https://i.imgur.com/riCOQSn.png)
这就是一颗语法树，当我们把语法框架IF-THEN-ELSE抽离出来，用二元运算符作为语法树的节点

---
![](https://i.imgur.com/bKV6g83.png)
递归嵌套的声明是CFG的重要内容，以上例子中，EXPR表达式还可以循环代入，这就是推导*(derivation)*的重要内容

#### CFG的组成
![组成](https://i.imgur.com/gKerlaJ.png)

1.终结符集(小写)
2.非终结符集(大写)
3.开始符
4.产生式集

***其中终结符集不可被替换，非终结符集会被替换，开始符也许只有一个，我们依赖于产生式集做推导***

#### 详细(derivation)推导的过程
![](https://i.imgur.com/Luwd0jo.png)
1.产生式集左边称为左部，右边为右部
2.推导过程就是不断使用左部替代有右部的过程，直到没有终结符
3.归约*(reduction)*是推导的逆过程，就是从结果反推解析产生式
![](https://i.imgur.com/QRhIwUT.png)




![](https://i.imgur.com/81wH0UN.png)
我们通过产生式将非终结字符替换成终结字符

![星推导](https://i.imgur.com/2nQMvUu.png)
这个推导可以包含0步到无穷多步的推导，但是一般不常用到


![推导例子](https://i.imgur.com/JFQRM2W.png)

![答案](https://i.imgur.com/22E5tRP.png)
**注意语法树一定要画**
非终结式就是可以一直推导下去的部分

