# 问  
那这种情况下其实用LT和ET也差不多吧，LT是一旦缓冲区空出了一点就会触发写事件，用户可以补充数据进去，ET是只有缓冲区全空了才会触发写事件，无论哪种，数据最终都会发完  

# 答  
你的直觉非常敏锐，确实，**只要逻辑写得对，无论 LT 还是 ET，数据最终都能发完。**

但在实际的高并发工程中，这种“差不多”背后隐藏着**效率**和**安全性**的巨大差异。你提到的“缓冲区空出一点就触发”和“全空才触发”虽然殊途同归，但处理过程中的“骚扰频率”完全不同。

我们可以从以下三个深度维度来剖析为什么它们并不真的“差不多”：

### 1. 触发时机的精确定义（这是最大的误区）

你提到的“ET 只有全空才触发”其实是一个常见的误解。

* **LT (水平触发)**：只要 `Send Buffer` 的剩余空间 **大于** 低水位标记（通常是 1 字节），`epoll_wait` 就会不断地通知你。
* **ET (边缘触发)**：它不是等全空，而是等**“状态变化”**。
* **情况 A**：内核缓冲区满了，发出去一部分，**空出了空间**（从满到不满），触发一次。
* **情况 B**：你手动调用 `epoll_ctl` 重新关注 `EPOLLOUT`，触发一次。



### 2. 为什么 ET 在“写”这件事上更有优势？

想象一个场景：你有一个巨大的文件要发，内核缓冲区 64KB，文件 1MB。

* **LT 的麻烦**：
1. 你发了 64KB，缓冲区满了。
2. 下一轮 `epoll_wait` 返回，提示可写。你尝试写，结果返回 `EAGAIN`（因为内核还没来得及发出去）。
3. `epoll_wait` **又**返回，提示可写。你又尝试，又 `EAGAIN`。
4. 这种反复的“空唤醒”会浪费大量 CPU 周期。为了避免这个，LT 模式必须在 `EAGAIN` 时关注 `EPOLLOUT`，在发完后**立刻注销** `EPOLLOUT`。这涉及大量的系统调用（`epoll_ctl`）。


* **ET 的优雅**：
1. 你发了 64KB，缓冲区满了，返回 `EAGAIN`。
2. 你不需要注销事件，直接回去睡大觉。
3. 内核把这 64KB 发出去了，**产生了一个跳变**，通知你一次。
4. 你起来继续写，直到再次 `EAGAIN`。
5. 整个过程，`epoll_wait` 只会因为“确实有空间了”才叫醒你，没有无效的骚扰。



### 3. “数据最终都会发完”，但吞吐量不同

你说得对，结果是一样的，但**过程的开销**决定了并发上限。

* **LT 像是一个碎碎念的老师**：只要你没写完作业，他就每秒进教室问你一次“写完没？”。虽然你能写完，但你被问烦了（上下文切换开销）。
* **ET 像是一个高冷的导师**：他只在你提交了一部分、他改完了、有空位给你继续写的时候才发个邮件通知你。你平时可以专心做别的事。

---

### ⚖️ 核心总结：什么时候它们真的“差不多”？

在以下两种情况下，LT 和 ET 的表现确实几乎没有区别：

1. **数据量很小**：如果你发的报文每次都能一次性塞进内核缓冲区（比如几十个字节），`send` 直接成功，你根本不需要关注 `EPOLLOUT` 事件，这时候 LT 和 ET 都在睡觉，表现一致。
2. **并发量极低**：当你的服务器只有几十个连接时，系统调用的开销微乎其微，CPU 根本跑不满，这时候为了代码简单，用 LT 更好。

### 💡 给你的 Demo 一个建议

既然你在写基于 muduo 的 Demo，muduo 采用 LT 是因为它有一套完善的 `Buffer` 管理机制。

在 muduo 中，处理写事件的逻辑是：

1. **直接 `send**`。
2. 如果没发完，才 `enableWriting()`（底层是 `epoll_ctl` 注册 LT 的写）。
3. 等到回调 `handleWrite` 把 `outputBuffer_` 彻底清空了，立刻 `disableWriting()`。

这种**“按需关注”**的策略，让 LT 也能表现得像 ET 一样高效，同时又保持了编程的简单。

**你现在的 `TcpServer::onMessage` 里是直接 `send` 的，没有处理“没发完”的情况。要不要我帮你写一个适配你当前 `Connection` 类的 `send()` 成员函数，让它能处理内核缓冲区写满的情况？**