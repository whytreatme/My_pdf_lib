# 问  
按照我的理解，其实就是两张位图或者说两张表的问题，我用户态维护了一张实时连接表，所有目前在连接状态的socket都在我这张表中，内核维护一张实时事件表，这个表是由poll读取到的内核中我看不到的信息决定的，这两张表是相互关联的，实时事件表从实时连接表划定的范围(maxfd)去做检索，实时连接表依靠实时事件表的反馈(FD_ISSET作为接口)对自身进行增删顺便处理写的问题，我理解得对吗？ 

你这个“两张表”的抽象**整体方向是对的**，但有几处细节要修一修，不然以后容易跟真正的实现对不上号。

我分点帮你校正一下你的模型。

---

## 先说结论版模型（你可以先记住这个）

实际上有**三层东西**：

1. **内核真实状态**：

   * 每个 fd 对应一个 `struct file` / `socket` / 缓冲区 / 状态（可读不可读、对端关闭、错误等）
   * 这是“事实世界”，一直存在。

2. **用户态传给 select 的“关注集合”（fd_set）**：

   * 你关心哪些 fd，就在 fd_set 里置 1。
   * 这是你维护的那张“连接表”（其实是“监听表”，不一定全是连接）。

3. **内核在一次 select 调用期间生成的“就绪集合”（内核拷贝的 fd_set）**：

   * 内核复制你的 fd_set → 在内核里遍历 + 调各个 fd 的 `poll()` 回调判断就绪 → 把就绪的 bit 保留，不就绪的置 0 → 再复制回用户态，覆盖你原来的 fd_set。
   * select 返回后，你 `FD_ISSET` 的其实是“就绪集合”。

所以你可以理解成：

> **你给内核一张“我关心谁”的表 →
> 内核根据自己手上的真实状态，算出“谁现在就绪了”的表 →
> 把这张“结果表”塞回给你。**

---

## 针对你说的每一句来修正一下

### ①「我用户态维护一张实时连接表，所有目前在连接状态的 socket 都在我这张表中」

**差不多，但有两点要注意：**

* 这张表**是不是“所有连接”取决于你自己**。
  你完全可以有些连接不用 select 管，而是单独阻塞 `recv()`，理论上没限制。
* 它更准确叫**“关心哪些 fd 的监听表”**，而不仅是“已连接”的 socket，例如：

  * `listenfd` 也是一个 fd
  * 你也可以把管道、文件、终端 fd 放进去

所以叫“实时连接表”略窄，但思路 OK。

---

### ②「内核维护一张实时事件表，这个表是由 poll 读取到的内核中我看不到的信息决定的」

这里要修两点：

1. 这张“实时事件表”**不是长期维护的**，而是：
   👉 **每次 select 调用，内核临时 copy 一份 fd_set，在这次调用期间用来写结果，用完就丢。**
   内核长期维护的是“真实世界：每个 fd 对应的 file/socket 状态”。

2. 你说的「poll 读取到的内核中我看不到的信息」——
   这里的 “poll” 不是 `poll()` 系统调用，而是每个文件有一个 `->poll()` 回调，
   比如 TCP socket 对应的是 `tcp_poll()`，它会根据 socket 的缓冲区状态判断：

   * 收缓冲区是否有数据（可读）
   * 发缓冲区是否有空间（可写）
   * 对端是否关闭（可读，read 返回 0）
   * 是否有错误（异常）

   所以更精确地说：

   > **内核在一次 select 中，对你关心的 fd 逐个调用它们的 `poll()` 方法，
   > 然后把结果写到这次调用专用的“内核版 fd_set”里。**

---

### ③「这两张表是相互关联的，实时事件表从实时连接表划定的范围(maxfd)去做检索」

这句基本对，但再精细一点：

* 内核遍历 `fd = 0..maxfd`，
* 对于每个 fd：

  * 如果**你那张“关注表”的 bit 不是 1** → 直接跳过
  * 如果 bit = 1 → 调它的 `poll()` 看是否就绪，写入内核 fd_set

所以“范围 = maxfd + 用户 fd_set 的 bit”。

---

### ④「实时连接表依靠实时事件表的反馈(FD_ISSET 作为接口)对自身进行增删顺便处理写的问题」

这里要分开说：

1. select 结束后，**你手上的 fd_set 已经被“就绪结果”覆盖了**：

   * 就绪的 fd → bit = 1
   * 不就绪的 fd → bit = 0

2. 至于“对自身增删”，其实是**你下一次 select 前，自己根据业务逻辑重新 FD_SET/FD_CLR 出来的**，不是内核帮你维护的。

所以更准确说法是：

> select 用“就绪表”覆盖了你传进去的那张 fd_set，
> 你通过 FD_ISSET 看哪些 fd ready，并根据业务决定：
>
> * 这个 fd 要不要继续在下一轮 select 里 FD_SET
> * 要不要 close 掉
> * 要不要新增一个新 fd（connect/listen accept）

---

## 再给你一个更准确的抽象

你现在的思路可以升级为这样：

* **用户态维护的是：“我关心它们”（监控集合）**
* **内核维护的是：“它们现在什么状态”（真实资源状态）**
* **select 做的是：“根据真实状态，在你关心的这群 fd 中标出‘现在 ready 的那几个’”**

用更拟人的说法：

* 你对内核说：

  > “这 0..maxfd 里这些 fd，我关心读/写/异常，你帮我看看谁现在可以干活。”

* 内核看了看自己的账本（所有 fd 对应的 socket/file 状态），
  在你递给它的那张“名单”（fd_set）上打勾：

  > “这几个现在可以，其他的你别动。”

* 然后把打完勾的名单还给你（覆盖原 fd_set），
  你用 `FD_ISSET` 看哪几个被勾了，逐个处理。

---

## 对你的理解做个总评

* 「两张表」这个抽象 ✅ 方向是对的
* 你意识到 maxfd 只是检索范围 ✅ 对
* 你知道 kernel 有自己的“不可见信息”，select 只是接口 ✅ 对
* 细节上要修的是：

  * 内核那张“事件表”是**每次 select 临时 copy + 临时写结果**，不是长期结构
  * fd 的复用与 fd_set 无关
  * “未就绪 bit”只是“现在 I/O 会阻塞”，不是“没有报文/没有在某时间内发数据”


# 问 
画个模型的示意图给我看看  

好，直接给你画一张**“一次 select 调用的完整模型示意图”**。
就按你说的“两张表”来画：一张是你维护的**关注集合表**，一张是内核这次临时算出来的**就绪结果表**。

---

## 🧩 整体结构：用户态 vs 内核态

```text
┌─────────────────────────────── 用户态（User Space） ────────────────────────────────┐
│                                                                                     │
│  你的程序：                                                                          │
│                                                                                     │
│   1. 维护一张“关注哪些 fd 的表”：                                                   │
│                                                                                     │
│          fd_set readfds;                ← 你的一张“关注表”（位图）                  │
│          FD_ZERO(&readfds);             ← 全部清 0                                   │
│          FD_SET(listenfd, &readfds);    ← 关心 listenfd                               │
│          FD_SET(connfd1, &readfds);     ← 关心 connfd1                                │
│          FD_SET(connfd2, &readfds);     ← ...                                       │
│                                                                                     │
│   2. 调用 select，把这张表“交给内核”：                                              │
│                                                                                     │
│          nready = select(maxfd+1, &readfds, NULL, NULL, &timeout);                  │
│                         │                                                           │
└─────────────────────────┼─────────────── 内核态（Kernel Space） ─────────────────────┘
                          │  系统调用陷入（sys_select）
                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              内核做的事情（一次调用期间）                          │
│                                                                                     │
│  1. 拷贝你的位图（关注表）到内核：                                                  │
│                                                                                     │
│      用户态 readfds  ──copy_from_user()──►  内核态 in_fds（本次调用的“工作表”）    │
│                                                                                     │
│  2. 内核遍历 fd=0..maxfd：                                                         │
│                                                                                     │
│      for fd in [0 .. maxfd]:                                                       │
│          if in_fds[fd] == 1:        ← 你关心这个 fd 吗？                            │
│              调用对应 file->poll()  ← TCP/pipe/文件… 各自实现 poll 回调             │
│              根据真实状态判断：                                                     │
│                  可读？→ 把结果 in_fds[fd] 置 1                                     │
│                  不可读 → in_fds[fd] 置 0                                          │
│          else:                                                                     │
│              直接跳过                                                              │
│                                                                                     │
│     （这个循环就是“对所有你关心的 fd 做一次 I/O 状态检查”的过程）                 │
│                                                                                     │
│  3. 处理完后，把结果拷贝回用户态：                                                  │
│                                                                                     │
│      内核态 in_fds ──copy_to_user()──► 用户态 readfds（原来的表被“就绪结果”覆盖）  │
│                                                                                     │
│  4. select 返回：                                                                   │
│                                                                                     │
│      返回值 nready = 本次就绪的 fd 个数                                             │
└─────────────────────────────────────────────────────────────────────────────────────┘
                          ▲
                          │
┌─────────────────────────┼───────────────────────────────────────────────────────────┐
│                         │  回到用户态                                               │
│  你的程序继续干：        │                                                          │
│                         │                                                          │
│   3. 遍历“被内核改过的 readfds”，找出哪些 fd 就绪：                                │
│                                                                                     │
│       for fd in [0 .. maxfd]:                                                      │
│           if (FD_ISSET(fd, &readfds)) {    ← 现在这张表是“就绪表”                   │
│               // 说明这个 fd 这轮可以读                                           │
│               handle_read(fd);                                                    │
│           }                                                                        │
│                                                                                     │
│   4. 根据业务逻辑决定：                                                             │
│       - 某些 fd 读完就 close() -> 下次不再关心                                    │
│       - 新建立的连接 FD_SET 进下一轮 select 的集合                                 │
│       - 下次 select 前重新构造新的 readfds                                         │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 🔍 用你原来的说法来翻译一下这张图

* **你维护的“实时连接表”**
  = 用户态的 `fd_set readfds`（每轮调用前你自己 FD_ZERO / FD_SET 出来的）

* **内核维护的“实时事件表”**
  = 每次 select 调用时临时 copy 的那份 fd_set（`in_fds`），
  内核根据真实 socket/file 状态 + 各自的 `poll()` 回调，把就绪 fd 的 bit 置 1，未就绪清 0。

* 两者关系是：

  * 你给内核一个“我关心谁”的集合
  * 内核在这上面打勾：“现在谁 ready”
  * 然后把“打勾后的表”还给你
  * 你用 `FD_ISSET()` 读出来，逐个处理

**关键点：**

* 内核那张“工作表”是每次 select 临时存在的，不是长期维护的结构
* 真正长期存在的是：

  * 内核的 socket/file 状态（缓冲区、TCP 状态机等）
  * 你用户态维护的“下一轮想监控哪些 fd 的集合”

---

如果你想，我可以再画一张“epoll 的示意图”，
你就能直观对比：select 的“每次 copy+扫描” vs epoll 的“注册一次+事件就绪推送”。


# 问  
未就绪的状态和读写的缓冲区有关，如果读缓冲内有数据可读，那就是读就绪，如果过写缓冲内缓冲区不满就是写就绪  

对，你这句话抓到**核心机制**了，只是可以再精细一点，把“就绪/未就绪”和“会不会阻塞”直接对应起来，就彻底通了。

我给你用「**read 就绪 / write 就绪 / 未就绪**」这三个角度整理一下。

---

## 1. 读就绪：本质＝`read/recv` 调用**不会阻塞**

对一个 TCP socket 来说，内核判断“读就绪”大致是这几种情况之一：

1. **接收缓冲区里有数据**

   * 有至少 1 字节数据在 `recv buffer` 里
   * 调用 `read/recv` 会立刻返回 >0
     👉 这是你说的：“读缓冲区有数据可读”的情况 ✔

2. **对端发送了 FIN（对端关闭写）**

   * 缓冲区里已经没有数据，但对端发了 FIN
   * 再调用 `read/recv` 会立刻返回 0（EOF）
   * 这个也算“读就绪”，只是读出的不是有效数据，而是“对端关了”

3. **有错误待处理**（错误也算就绪）

   * 比如连接被重置（RST）、网络错误
   * `read/recv` 立刻返回 -1，并设置 errno
   * 对 select/poll 来说，这种也会把 fd 标成“可读”

4. **对监听 socket 来说**

   * `listenfd` 的“读就绪” = **内核 accept 队列里有待 accept 的连接**
   * 这时 `accept()` 不会阻塞

总结一句：

> **读就绪 = 调用 read()/recv()/accept() 不会阻塞，不管返回的是数据、EOF，还是错误。**

---

## 2. 写就绪：本质＝`write/send` 调用**不会阻塞**

你说的这句也对：

> “写缓冲区不满就是写就绪”

更精确一点：

1. 内核发送缓冲区（send buffer）里还有**可用空间 ≥ SO_SNDLOWAT**

   * 默认 low water mark 是 1 字节
   * 只要还能塞下去一点数据，内核就认为“写就绪”
   * `send/write` 立刻返回 >0（或至少能发送一些）

2. 如果发送缓冲区满了（比如窗口太小、对端收不动）

   * 再 `send` 会阻塞（阻塞 socket）
   * 对非阻塞 socket 会返回 -1, errno = `EAGAIN` / `EWOULDBLOCK`
     👉 这种情况下，**写 bit 就是未就绪**。

3. 有致命错误（比如 RST）

   * 下一次 `send` 立刻返回错误
   * 对 select/poll 来说，这种也算“写就绪/异常就绪”

总结一句：

> **写就绪 = 调用 write()/send() 不会阻塞，不管是成功发出去，还是立刻报错。**

---

## 3. “未就绪”= 现在去 I/O 会阻塞（对非阻塞 fd 就是 EAGAIN）

所以可以这样统一理解：

* **读未就绪**：

  * 接收缓冲区里**没有数据**，
  * 没有 FIN，
  * 没有错误，
    👉 此时 `read/recv` 会阻塞（或非阻塞 fd 返回 EAGAIN）

* **写未就绪**：

  * 发送缓冲区已经塞满（或者达到了某些条件），
    👉 此时 `write/send` 会阻塞（或非阻塞 fd 返回 EAGAIN）

select/poll/epoll 的“就绪位”本质就是：

> “**如果现在对这个 fd 做某种 I/O 调用，会不会卡住？**
> 不会卡住 = 就绪（bit=1）；会卡住 = 未就绪（bit=0）。”


