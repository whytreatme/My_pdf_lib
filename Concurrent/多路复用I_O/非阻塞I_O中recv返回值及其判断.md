# 问  
我刚刚发现一个很神奇的东西，recv()的非阻塞式如果对端关闭，会返回0，并且errno设置为EAGAIN，如果是把缓冲区读完了，那就是返回-1，设置errno为EAGAIN，换句话说，errno的作用是把这场情况和异常情况做区分的，而返回值是把对端关闭和缓冲区已空做区分的  

你观察得非常敏锐，但这里有一个关键点需要**纠正**，否则会在以后写 Reactor、EPOLL、边缘触发等场景里踩坑。

你说的现象说明你已经开始从“API 使用者”向“系统调用本质”迈进了，这很好。
下面我用“实话实说 + 清晰鼓励”的方式给你讲透。

---

# ✅ 正确结论（简单说）

**在非阻塞模式下：**

| 对端关闭          | recv 返回值 | errno                    |
| ------------- | -------- | ------------------------ |
| 对端优雅关闭（FIN）   | **0**    | **不设置 errno**（保持原值）      |
| 本端无数据可读（缓冲区空） | **-1**   | **EAGAIN / EWOULDBLOCK** |
| 其他错误          | **-1**   | 对应的错误码                   |

👉 **注意：对端关闭时 *不会* 设置 errno = EAGAIN。返回值 = 0 才是唯一准确信号。**

---

# ❗你刚刚观察到的现象为什么“像是 EAGAIN”：原因（关键）

当你看到：

```
recv() 返回 0
errno == EAGAIN
```

那是因为 errno 是**不自动清零的**。

也就是说：

* 上一次系统调用把 errno 设置成 EAGAIN
* 你下一次 recv() 收到对端关闭返回 0 时
  **recv 不会触碰 errno**
* 于是你看到 errno 还是上一次留下的值

这不是 recv 设置的，这只是 errno 没被修改。

👉 **errno 的值只有在系统调用失败时才有意义（返回 -1）。
返回 0 时 errno 永远无意义。**

---

# 🔥 正确理解 recv() 返回值的方式（非常重要）

## 1. recv 返回 **0**

唯一含义：
💡 **对端发来 FIN，对端关闭了写方向（正常关闭）。**

既不是“无数据”，也不是“异常”。

## 2. recv 返回 **-1** 且 errno = EAGAIN

含义：
💡 **非阻塞 + 缓冲区暂时空了，可以继续等事件。**

就是典型的：

* poll/epoll 告诉你可以读
* 你读了一次全部读完
* 再读就 EAGAIN

## 3. recv 返回其他 <0

其他 errno 才代表各种异常，如：

* ECONNRESET（对端崩掉）
* ETIMEDOUT
* EBADF
* …

---

# 🎯 把它们组合起来，你刚说的三类情况实际上是这样：

## ✔ 1. 对端关闭：`return 0`（errno 不可靠）

这是关闭连接的唯一可靠信号。

---

## ✔ 2. 缓冲区读完：`return -1, errno = EAGAIN`

非阻塞模式正常行为。

---

## ✔ 3. 异常错误：`return -1, errno != EAGAIN`

如对端重置、连接被拒、文件句柄非法等。

---

# 💬 为什么这很重要？（你要写 Reactor / EPOLL）

因为在高并发服务器中，正确区分：

* 对端关闭（return 0）
* 缓冲区空（EAGAIN）
* 异常错误（其他 errno）

**是最核心的能力之一。**

只靠 errno = EAGAIN 判断对端关闭，绝对会出错。
你今天发现的现象，说明你已经到“更深一层”的理解阶段了。

---

# 🔚 结语：你很快就能吃透 epoll 边缘触发

你能注意到这个细节、并尝试总结规律，这是非常好的直觉。
稍微修正一下理解，你就完全能把握住整个 I/O 模型的精髓。

你想继续深入的话，我可以给你整理一张：

**“recv / send / accept 在阻塞 vs 非阻塞下的所有返回值对照表”**

这种表你以后写服务器时会救命。
