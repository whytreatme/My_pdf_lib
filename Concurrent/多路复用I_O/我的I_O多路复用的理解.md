# 阻塞问题
在进/线程中，发起一个调用时，在调用返回之前，进/线程会被阻塞等待，等待中的进/线程让出CPU的使用权。
## 阻塞的原因及分类  
对于I/O复用来说，最重要的一个问题就是阻塞问题，会阻塞的函数有connect()、accept()、send()、recv()，不同的阻塞有不同的阻塞条件，比如connect是三次握手没有完成就会阻塞等待，accept是队列中还没有完成三次握手ESTABLISH的会阻塞等待，send/recv则和缓冲区有很大的关系，send是自身缓冲区满了就会阻塞等待，recv是自身缓冲区空了会阻塞等待，但是一端的写缓冲会因为对端读缓冲饱和而受到tcp滑动窗口的控制，写缓冲因为没收到对端 ACK而无法删除已发送（未确认）数据，从而变满。

## 阻塞的返回  
如果设置了非阻塞，那在发起调用时，就会立即返回
立即返回同时会设置对应的errno，connect比较特殊是EINPROGRESS，其它是EAGAIN
这非阻塞返回errno，并不是真的失败,具体还要看是否文件描述符的其它属性，比如非阻塞 connect 的成功判断：写事件触发后，通过 getsockopt(SO_ERROR) 获取错误码判断。

# 事件地监听问题  
要在一个进/线程中多路复用，重要的就是把不同socket触发地事件按线性处理，同时不能阻塞，类似于把并行改为高速地串行，这其中最重要的就是对每一时刻发生事件的关注，事件的关注是有内核监管的，包括收发缓冲，包括收到对端关闭的信号或者新连上来的客户端等等，用户态借助系统调用为抓手得到这些信息，根据这些信息实现相应的处理  

## 监听包括  
对于服务端来说监听读事件是最重要的，有几种情况会触发读事件  
1.有新的客户端练上来  
2.有对端关闭了通道  
3.接受缓冲区有可读的数据  
4.在发送过程中收到的重传等各种错误信息  

**POLLERR/POLLHUP/POLLNVAL 属于独立事件，不依附于读写事件。**

## 多路复用的各种模型  
select：扫描 0~maxfd 的 bitmap → O(maxfd)
poll：扫描 pollfd 数组 → O(nfds)
epoll：事件驱动，只遍历 ready 队列 → O(ready)
