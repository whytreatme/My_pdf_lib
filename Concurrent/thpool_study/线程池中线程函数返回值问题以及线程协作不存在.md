# 问_1  
```c
typedef struct job{
	struct job*  prev;                   /* pointer to previous job   */
	void   (*function)(void* arg);       /* function pointer          */
	void*  arg;                          /* function's argument       */
} job;
```  
job这样设计，那是不是说明不能处理有返回值的函数  

# 答_1  
是的，从 `job` 结构体和 `thread_do` 的执行代码逻辑来看，该线程池设计方案**直接上不支持**获取函数的返回值。

因为 `function` 的原型定义为 `void (*)(void*)`，且工作线程在调用时并没有接收和存储任何返回数据：

````c
// ...existing code...
			if (job_p) {
				func_buff = job_p->function;
				arg_buff  = job_p->arg;
				func_buff(arg_buff); // 执行后返回值丢失（且原型返回 void）
				free(job_p);
			}
// ...existing code...
````

### 如果需要返回值，通常有以下两种权宜之计：

1.  **通过参数指针回传**：
    向 `func_buff` 传入一个结构体指针，该结构体内部包含输入参数和用于存放结果的变量空间。函数执行过程中将结果写入该空间。
2.  **自定义包装**：
    在 `arg` 传入的结构体中包含信号量或条件变量，当函数执行完结果写入后，通知（signal）主控线程读取。


# 问_2  
那么就整个线程池的设计思想而言，每个线程该处理的任务都是不带返回值的吗？线程之间存在协作吗？比如这个线程的计算结果为另外一个线程所用，还是说每个子线程都像是独立的小主线程一样处理问题  

# 答_2  
就这个线程池的设计思想和通用多线程模型而言，可以从以下几个维度来理解：

### 1. 任务返回值的处理
在 C 语言的底层线程池设计中，任务通常定义为 `void (*)(void*)`。这并不意味着不能处理有返回值的计算，而是**返回方式发生了改变**：
*   **非阻塞/异步思想**：线程池的核心是“发后即忘”（Fire and Forget）。主线程把任务丢进去就继续扫地去了，它不希望在那里死等某个子线程的返回值。
*   **如何拿回结果**：如果你需要结果，通常是在传入的 `arg` 参数中包含一个指向结果缓冲区的指针。子线程算完后把结果填进去。
*   **更高级的做法**：在更复杂的系统中（如 C++ 或 Java），会有 `Future` 或 `Promise` 机制，但在本项目这种简单的 C 实现中，它是**不直接支持**返回值的。

### 2. 线程之间的协作
在这个特定的线程池实现中，子线程之间**不存在直接协作**。
*   **独立性**：每个子线程确实像是一个“独立的小工作者”。它们唯一的共同点是去同一个“仓库”（任务队列）里领活干。
*   **无状态**：线程 A 不知道线程 B 在干什么，也不知道线程 B 算出了什么。
*   **协作的实现位置**：协作通常发生在**应用层**。比如你把一个大任务拆成 10 个小任务丢进池子，主线程调用 `thpool_wait()` 等待它们全部完成。这是一种“同步点”式的协作，而不是线程间的直接通信。

### 3. 每个子线程的角色
正如你所说，它们更像是**独立的小主线程**，或者说是**通用型工人**：
*   **通用工人模型**：它们是“无感知”的。池子只是给它们提供了一个持续运行的死循环。
*   **解耦**：这种设计实现了任务（Task）与执行者（Executor）的解耦。你只需要关注你的函数逻辑，而不需要关心是哪个线程执行了它。

### 4. 线程间通信（如果你需要）
如果你希望线程之间有协作（比如 A 的结果给 B），你需要自己构建机制：
*   **流水线模式**：任务 A 执行完后，在其函数末尾调用 `thpool_add_work` 将任务 B 加入队列。
*   **共享变量**：通过全局变量或传入的共享指针进行通信（需要配合 `mutex` 加锁）。

**总结**：
这个线程池属于**“生产者-消费者”**模型。它的设计思想是**任务高度独立、执行高度并行**。它最擅长处理的是互不干扰的密集型计算或 IO 任务，而不是具有复杂逻辑依赖的协作任务。

