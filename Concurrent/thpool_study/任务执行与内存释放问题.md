# ai studio 问  
关于 malloc： 这里的 newjob 是在堆上动态分配的。请发挥你的追踪本领：这个 malloc 出来的内存，最终是在哪里被 free（销毁）掉的？（这是防止内存泄漏的关键！）  


# 我的错误答案  
这个内存是在jobqueue_clear中被free掉的  
```c
static void jobqueue_clear(jobqueue* jobqueue_p){

	while(jobqueue_p->len){
		free(jobqueue_pull(jobqueue_p));
	}

	jobqueue_p->front = NULL;
	jobqueue_p->rear  = NULL;
	bsem_reset(jobqueue_p->has_jobs);
	jobqueue_p->len = 0;

}

```

# 正确答案  
你提到了 jobqueue_clear，这没错，但那是**“大扫除”（线程池销毁时清空未完成的任务）。
但在“正常的剧本”**里，每一个被执行掉的任务，其内存必须在执行完后立即释放，否则线程池运行几天后内存就爆了。  
```c
job* job_p = jobqueue_pull(&thpool_p->jobqueue);
			if (job_p) {
				func_buff = job_p->function;
				arg_buff  = job_p->arg;
				func_buff(arg_buff);
				free(job_p);
			}
```
不能等到最后线程池要关了才来释放任务的内存，如果线程池一直不关，那任务的内存空间就一直得不到释放，任务完成了，就没用了，空间该释放了