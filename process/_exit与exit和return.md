## 问  
我不明白为什么用cerr不用stderr，还有什么时候用exit什么时候用return  

这两个问题问得非常好。
它们属于 **C / C++ 程序行为最基础的底层机制**，搞明白它们之后，你写系统编程代码时就不会再犹豫了。
我来用你能直接带入自己代码的方式讲清楚。

---

## 一、`cerr` vs `stderr`

它们都表示“**往标准错误输出打印内容**”，但所属世界不一样：

| 名称       | 属于      | 类型           | 是否带缓冲                 | 推荐场景                                      |
| -------- | ------- | ------------ | --------------------- | ----------------------------------------- |
| `stderr` | C 语言标准库 | `FILE*`（指针）  | **不带缓冲**              | 用在 C 风格的 `printf` / `fprintf(stderr,...)` |
| `cerr`   | C++ 标准库 | `ostream` 对象 | **默认无缓冲（等价于 stderr）** | 用在 C++ 的 `cout` / `cerr` 流体系中             |

---

### 📘 举例：

```cpp
// C 写法
fprintf(stderr, "fork error: %s\n", strerror(errno));

// C++ 写法
cerr << "fork error: " << strerror(errno) << endl;
```

这两句作用一模一样，只是写法不一样。

**总结一句话：**

> 用 `cerr` 是因为你写的是 C++ 程序，
> 它跟 `cout` 一样可以用 `<<` 输出，更方便。
> 但它实际上就是往 `stderr` 输出，作用没区别。

---

### 📎 补充：

在 Linux 命令行里，
标准输出 `stdout` 和标准错误 `stderr` 是两个不同的文件描述符（1 和 2）：

```bash
$ ./a.out > output.txt 2> error.txt
```

* `>` 捕获的是标准输出；
* `2>` 捕获的是标准错误。

无论你在代码里用 `cerr` 还是 `fprintf(stderr, ...)`，
都属于“标准错误输出”（即 fd = 2）。

---

## 二、`exit()` vs `return`

这两个是“**结束程序**”的不同方式。
关键在于 **它们结束的范围不同**：

| 场景                   | 结束什么      | 执行清理                | 推荐使用地方                     |
| -------------------- | --------- | ------------------- | -------------------------- |
| `return`             | 当前函数      | 是（调用者还会继续）          | 普通函数返回                     |
| `return`（在 `main` 里） | 整个程序      | 是                   | **C++ 推荐的程序结束方式**          |
| `exit(code)`         | 整个程序      | 是（调用所有 atexit 清理函数） | 在任意函数中直接结束程序               |
| `_exit(code)`        | 当前进程（不清理） | **不执行清理、不刷新缓冲**     | **子进程 exec 失败后退出**（系统编程常用） |

---

### 📘 举例：

#### ✅ 1. 普通 main 程序用 `return`

```cpp
int main() {
    if (argc < 2) {
        cerr << "Lack of argument\n";
        return 1; // 返回给操作系统退出码 1
    }
}
```

这是**正常退出**。
相当于 `exit(1)`，只是写法更现代，更容易读懂。

---

#### ✅ 2. 在子进程（`fork()` 后）用 `_exit`

```cpp
pid_t pid = fork();
if (pid == 0) {
    execvp(argv[1], &argv[1]);
    cerr << "exec failed\n";
    _exit(127); // 不要用 exit()，否则会刷新缓冲区两次
}
```

原因：

> 子进程是从父进程复制出来的，如果你用 `exit()`，
> 它会再次刷新父进程复制来的所有缓冲区，可能导致输出重复。
> `_exit()` 是直接告诉内核“我死了”，不清理、不刷新，最安全。

---

#### ✅ 3. 在任何函数中想立即终止整个程序

```cpp
void fatal(const char* msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}
```

`exit()` 会：

* 刷新所有输出流；
* 调用所有 `atexit()` 注册的清理函数；
* 然后结束进程。

---

## ✅ 一图总结：

| 名称        | 属于      | 是否刷新输出 | 结束范围 | 常见用法       |
| --------- | ------- | ------ | ---- | ---------- |
| `return`  | C/C++语法 | 是      | 当前函数 | 正常退出 main  |
| `exit()`  | C 库函数   | 是      | 整个进程 | 普通函数中提前结束  |
| `_exit()` | 系统调用    | 否      | 当前进程 | 子进程退出时使用   |
| `stderr`  | C 库输出指针 | 否      | -    | C 风格错误输出   |
| `cerr`    | C++ 流对象 | 否      | -    | C++ 风格错误输出 |

---

## 💬 放到你自己的程序里

* 你写的是 C++ 程序 → 用 `cerr`；
* main 里想结束 → 用 `return`；
* 子进程 `execvp` 失败 → 用 `_exit()`；
* 遇到严重错误想立即结束整个程序 → 用 `exit()`。

---

要不要我帮你画一张图，把“`return`、`exit`、`_exit`”的调用路径关系（用户态 → glibc → 内核）画出来？
看一眼就知道为什么 `_exit` 不会刷新缓冲区。
