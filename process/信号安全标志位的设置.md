# 问  
怎么设置标志位我没学过  

我来手把手教你，**非常简单**，你立刻就能学会，而且跟你已经学过的知识完全兼容。

你只需要理解三件事：

---

# ✔ 第一件事：信号处理函数里不能随便写变量

信号是在任意时刻打断你的代码的，因此**信号处理函数只能操作“异步信号安全”的东西**。

普通变量不是异步信号安全的（编译器可能优化、可能分成多步写入），
但 C 标准专门提供了一个“保证单步写入”的类型：

---

# ✔ 第二件事：`sig_atomic_t` —— 信号专用的变量类型

写法：

```cpp
volatile sig_atomic_t g_stop = 0;
```

关键点：

* **sig_atomic_t**：保证对它的读写是原子的（不会被分割成 2 步，所以 signal 重入不会破坏它）。
* **volatile**：告诉编译器：别优化掉读写，信号处理函数修改它时，主线程必须能看到。

这是信号处理通用的写法。

你只要这么写：
**就可以放心地在 handler 里修改这个变量，绝对不会有数据竞争、重入破坏的问题。**

---

# ✔ 第三件事：信号处理函数只做一件事：改标志位

示例（父进程收到 Ctrl+C 的 handler）：

```cpp
void FathINT(int sign) {
    g_stop = 1;   // 告诉主循环：该退出了
}
```

你会发现我们不做：

* 不做 `close()`
* 不做 `waitpid()`
* 不做 `cout`
* 不做系统调用

因为**信号处理中唯一绝对安全的事，就是写一个 `sig_atomic_t` 变量。**

我们利用这个特点，把所有“复杂逻辑”放到主循环中执行。

---

# ✔ 最后一步：主循环检查标志位

你的主循环原来是：

```cpp
while (true) {
    // accept, fork...
}
```

改成：

```cpp
while (!g_stop) {
    // accept, fork...

    // 如果 accept 因信号中断
    if (errno == EINTR) {
        if (g_stop) break;
        else continue;
    }
}
```

这样：

* Ctrl+C（SIGINT）触发 → handler 把 `g_stop = 1`
* 主循环发现 g_stop = 1 → 跳出循环
* 跳出后，由父进程统一执行收尾（close + kill + waitpid）

处理流程简单、干净、安全。

---

# ✔ 全流程总结成 5 行给你：

```cpp
#include <signal.h>

volatile sig_atomic_t g_stop = 0;

void handler(int sign) { g_stop = 1; }

sigaction(SIGINT, &act, NULL);   // 绑定 handler

while (!g_stop) { ... }          // 主循环检查标志
```

就这么简单。

这 5 行，就是所有 Unix 程序优雅退出的基本骨架。

---

# ✔ 给你一个“极简骨架”版本，便于记忆

```cpp
#include <signal.h>
#include <unistd.h>
#include <iostream>
using namespace std;

volatile sig_atomic_t stop_flag = 0;

void stop_handler(int sign) {
    stop_flag = 1;
}

int main() {
    struct sigaction act;
    sigemptyset(&act.sa_mask);
    act.sa_handler = stop_handler;
    act.sa_flags = 0;
    sigaction(SIGINT, &act, NULL);

    while (!stop_flag) {
        cout << "工作中..." << endl;
        sleep(1);
    }

    cout << "程序优雅退出。" << endl;
    return 0;
}
```

运行后按 Ctrl+C：

```
工作中...
工作中...
^C程序优雅退出。
```

这就是“标志位”在信号里的全部用法了。

---

# 如果你愿意，我可以把你现在那份完整的 TCP 服务器代码

**重新生成一版注释极清晰、逻辑分层非常明确、标志位设计完全规范**的版本，让你之后所有项目都可以复用。
