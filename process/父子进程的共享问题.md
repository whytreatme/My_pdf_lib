## 问  
全局变量为父子进程共享吗？  

非常棒的问题，这是学习进程最容易混淆的一点之一。
答案是：

> **父子进程在刚刚 `fork()` 完成的那一刻看起来共享全局变量的值，但实际上它们各自拥有独立的副本。**
> **之后的修改互不影响。**

---

## 🔹一、为什么“看起来”共享？

在你调用 `fork()` 时，操作系统会：

* 复制父进程的整个虚拟地址空间（包括全局变量、堆、栈等）；
* 给子进程创建一份**几乎一模一样的内存布局**；
* 但这只是“看起来一样”——实际上是“写时复制（Copy-on-Write, COW）”。

也就是说：

> 子进程最开始的全局变量内容与父进程完全相同，
> 但任何一方一旦写入，就会触发内存页复制，变成自己的独立副本。

---

## 🔹二、示例代码演示

```c
#include <stdio.h>
#include <unistd.h>

int g = 100; // 全局变量

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 子进程
        g += 50;
        printf("Child: g = %d\n", g);
    } else {
        sleep(1); // 保证子进程先执行
        printf("Parent: g = %d\n", g);
    }

    return 0;
}
```

输出结果通常是：

```
Child: g = 150
Parent: g = 100
```

解释：

* 父子进程在 `fork()` 时，`g` 的初始值相同（100）。
* 子进程修改 `g` → 系统复制那一页内存。
* 父进程的 `g` 依然保持 100，不受影响。

---

## 🔹三、重点总结

| 阶段          | 状态     | 说明       |
| ----------- | ------ | -------- |
| `fork()` 之前 | 只有父进程  | 全局变量存在一份 |
| `fork()` 之后 | 父子各自一份 | 初值相同，但独立 |
| 任一修改        | 不再共享   | 写时复制机制触发 |

---

## 🔹四、延伸：什么时候才“真的共享”？

只有以下几种情况才是真正共享的：

1. **使用共享内存（System V IPC / mmap / shm_open 等）**

   ```c
   int shmid = shmget(...);
   int *ptr = shmat(shmid, NULL, 0);
   ```

   这种内存映射的区域在父子进程间是真共享。

2. **使用线程**

   * 多线程是同一个进程的不同执行流，共享全局变量和堆区。

---

## 🔹五、一句话记住

> `fork()` 后父子进程的全局变量是“拷贝一份的副本”，
> 不是共享；想共享得用共享内存。

---

要不要我给你画一张内存结构图（父进程→fork→子进程，标出文本段、数据段、堆、栈、写时复制过程）？
那张图能让你直观看出“看似共享，实则独立”的全过程。
