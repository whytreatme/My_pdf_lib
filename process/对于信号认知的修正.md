# 前言  
虽然对于信号的学习，我花费了不少的精力，知道信号的诸如信号的忽略，捕获，屏蔽等手段，以及信号的重入中断的问题，但是我对信号了解还不够全面，本文着重对信号认知的一次修正，其中包括信号默认行为的理解上  



## 问  
也就是说，我安装了信号处理函数才会到用户态的函数部分，才会有被打断的风险，我不安装，那信号来临就是默认行为，在内核中处理不会有打断的风险？  

对，你现在抓到核心了，不过还差半步，我给你精确捋清楚：

> **结论先说：**
>
> * “会不会跑到你写的 C 函数里去” —— 只取决于你**有没有给这个信号安装处理函数（或者设成 `SIG_IGN` 之外的东西）**。
> * “会不会打断当前正在干的事（比如 `accept`/`read`）” —— 跟**有没有 handler 都可能有关**，但这种打断只是让系统调用返回 `-1,EINTR`，不是你担心的那种“在用户态乱重入函数”。

下面分开讲两个层次，不然容易混：

---

## 1️⃣ 什么时候会“跑到你写的函数里”（有重入风险）？

只有这几种情况才会在**用户态**执行你的代码：

1. 你写了：

   ```cpp
   struct sigaction act;
   act.sa_handler = myhandler;
   sigaction(SIGINT, &act, NULL);
   ```

   或者：

   ```cpp
   signal(SIGINT, myhandler);
   ```

   这叫“捕获信号”。

2. 信号到达时，内核发现这个信号的处理动作是“调用用户 handler”，于是：

   * 暂停当前用户态执行；
   * 保存上下文；
   * 切到 `myhandler()` 去跑；
   * 跑完再恢复上下文，继续之前的代码。

**只有这时候才会有你担心的那种情况：**

* 在执行你正常函数 / 另一个 handler 的时候，被“异步地插入”一个新的 handler → 就涉及**重入**、**异步信号安全**这些问题。

> 👉 所以你问的这句：
>
> > “我安装了信号处理函数才会到用户态的函数部分，才会有被打断的风险”
>
> ✅ 没错，就是这个意思。
> 安装了 handler → 有可能“跳到你的 C 函数里” → 要考虑重入、哪些函数能安全调用等问题。

---

## 2️⃣ 如果我没有安装 handler，会发生什么？

这时候每个信号都有一个**默认动作**（disposition）：

* 有的默认动作是：**终止进程**（如 SIGINT、SIGTERM、SIGSEGV 等）；
* 有的默认动作是：**忽略**（如 SIGCHLD 默认是忽略）；
* 有的默认动作是：**终止并生成 core dump** 等等。

这类情况的共同点：

> 内核自己处理掉，不会跳到你写的任何 C 函数里。

所以你说的这句：

> “我不安装，那信号来临就是默认行为，在内核中处理不会有打断的风险？”

精确一点地说：

* 不会有 **“执行你写的用户态处理函数”** 的那种打断和重入风险 ✅；
* 但是：

  * 对于“终止类”信号（SIGINT 默认就是终止），整个进程直接死掉，谈不上“继续执行”；
  * 对于“忽略类”信号（比如 SIGCHLD），内核会更新一些状态（比如把子进程标成 zombie 或者直接回收），但是**不会执行你的代码**，也就没有 handler 的重入问题。

---

## 3️⃣ 还有一种“打断”：系统调用被 EINTR 中断

这个容易和“handler 重入”混在一起，你现在脑子里的“打断风险”其实把两个概念糊在一起了。

第二种打断是：

> 你在执行一个阻塞系统调用，比如 `accept()/read()/write()/sleep()`，
> 信号到了 → 系统调用提前返回，`errno = EINTR`。

这件事分两种情况：

### 情况 A：你对这个信号安装了 handler

* 信号来了：

  * 内核先暂停当前系统调用；
  * 跳到 handler 执行你写的代码；
  * handler 返回后：

    * 如果没指定 `SA_RESTART`，系统调用就直接失败返回 `-1,EINTR`；
    * 如果指定了 `SA_RESTART`，内核会自动重启部分系统调用。

这种情况下，你需要同时考虑：

1. **handler 里调用的函数是不是异步信号安全**（重入风险）；
2. **系统调用被 EINTR 打断后，你是不是要重试**。

### 情况 B：你*没有*给这个信号安装 handler（或设为 `SIG_IGN`）

* 默认动作是“终止”：进程直接死掉，不存在“继续执行”的打断问题；
* 默认动作是“忽略”：

  * 有些实现下，阻塞调用可能直接被重启，你感觉不到被打断；
  * 也可能返回 EINTR，但**仍然不会跳去执行你的 C 代码**，只是系统调用提前结束而已。

**关键点：**

> 就算有 EINTR 打断，跟“handler 重入”是两码事。
> EINTR 只是“系统调用被信号提前结束”，不会执行你的 handler（前提是你没安装）。

---

## 4️⃣ 回到你这几个具体担心上，帮你一条条钉死

> ① “FathINT 不会被其它信号重入吗？ChilEXIT 不会被其它信号重入吗？”

* FathINT：只对 SIGINT / SIGTERM 安装，且 `sa_mask` 里把这两个都加进去 → 在 FathINT 里，这俩信号都被屏蔽 → **不会重入**。
* ChilEXIT：只对 SIGTERM 安装，默认行为下，内核在 handler 运行时会屏蔽当前信号 → SIGTERM 自己不会重入；子进程也没装其他 handler → **也不会被别的信号重入**。

> ② “如果被 SIGCHLD 中断，因为没改 g_stop 所以父进程不会退出”

这一版里：

* 没有 `sigaction(SIGCHLD, ...)`；
* 所以 SIGCHLD 不会中断你去执行任何 C 函数，更不会跑进什么 `ChilResource`；
* 父进程退出与否**只受 SIGINT / SIGTERM（FathINT）影响**，和 SIGCHLD 完全无关。

> ③ “我不安装 handler，那信号来临就是默认行为，在内核中处理，不会有打断风险？”

精确说：

* 不会有“跑进你的 C 函数”的风险 ✅；
* 但可能：

  * 把进程直接干死（终止类默认动作）；
  * 或导致某个阻塞系统调用返回 EINTR（但不会执行 handler）。

---

## 5️⃣ 给你一句可以刻在脑子里的“信号脑图”

**把“打断”分成两种：**

1. **打断 + 跑 handler（才有重入问题）**

   * 只有你对这个信号用了 `signal/sigaction` 安装了处理函数（或 `SA_SIGINFO`）时才会发生。
2. **打断 + 系统调用返回 EINTR（只是调用失败，不是 handler）**

   * 有 handler 时更常见；
   * 没 handler 也可能发生（看默认动作和实现），但这跟“跑你代码”没关系。

你现在真正害怕的是第 ① 种。
那就简化策略：

* **只给少数信号装 handler**，而且 handler 只做“设标志位”这类一步到位的事；
* 其他信号一律不装 handler → 没有“跑用户态 handler”的打断，也就没有你说那种乱七八糟的重入风险。

---

你如果愿意，下一步我可以帮你：
**把你这套关于信号的理解，整理成一张「自己能看懂的速记表」**，贴到你的网络编程项目里当注释，用的时候随手翻一眼，心里就不会这么乱了。


## 我的总结
安装信号处理函数 = 捕获信号  
也就是说，如果不捕获信号，那信号到来就是默认的行为，这种情况下突然的中止才可怕，像是SIGCHLD这类默认忽略掉的信号对程序几乎没有影响，如果捕获信号，信号处理函数写得越复杂就越麻烦，写得越复杂反而越要考虑函数里面是不是异步信号安全的，捕获的信号越多，中断情形的考虑就越复杂  

## 默认信号处理行为一览  
信号名	信号值	默认处理动作	发出信号的原因
SIGHUP	1	A	终端挂起或者控制进程终止
SIGINT	2	A	键盘中断Ctrl+c
SIGQUIT	3	C	键盘的退出键被按下
SIGILL	4	C	非法指令
SIGABRT	6	C	由abort(3)发出的退出指令
SIGFPE	8	C	浮点异常
SIGKILL	9	AEF	采用kill -9 进程编号 强制杀死程序。
SIGSEGV	11	CEF	无效的内存引用（数组越界、操作空指针和野指针等）。
SIGPIPE	13	A	管道破裂，写一个没有读端口的管道。
SIGALRM	14	A	由闹钟alarm()函数发出的信号。
SIGTERM	15	A	采用“kill 进程编号”或“killall 程序名”通知程序。
SIGUSR1	10	A	用户自定义信号1
SIGUSR2	12	A	用户自定义信号2
SIGCHLD	17	B	子进程结束信号
SIGCONT	18		进程继续（曾被停止的进程）
SIGSTOP	19	DEF	终止进程
SIGTSTP	20	D	控制终端（tty）上按下停止键
SIGTTIN	21	D	后台进程企图从控制终端读
SIGTTOU	22	D	后台进程企图从控制终端写
其它	<=64	A	自定义信号
处理动作一项中的字母含义如下：
A 缺省的动作是终止进程。
B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。
C 缺省的动作是终止进程并进行内核映像转储（core dump）。
D 缺省的动作是停止进程，进入停止状态的程序还能重新继续，一般是在调试的过程中。
E 信号不能被捕获。
F 信号不能被忽略。

## 问  
如果我先忽略了SIGINT信号，然后安装了处理SIGTERM的handler，那当我进入handler的时候如果有一个SIGINT信号到了，会中断我还是被忽略掉？  


你这个问题问得非常关键，而且**直接决定你对信号模型是否真正理解了**。

我一句话先定性答案，再展开解释：

# ✅ **答案：不会中断，会被忽略掉。**

---

# 为什么？因为每个信号都有自己独立的处理方式（disposition）

Linux/Unix 的信号处理方式有三种：

1. **默认动作（default）**
2. **忽略（SIG_IGN）**
3. **用户自定义 handler（你的 `sigaction`）**

你给某个信号设置了什么处理方式，它就永远按照那个方式处理，与其它信号无关。

---

# 回到你的具体问题

## 情况复述：

* 你写了：

  ```cpp
  signal(SIGINT, SIG_IGN);  // 忽略 SIGINT
  sigaction(SIGTERM, &act, NULL);  // 安装 SIGTERM 的 handler
  ```

* 现在程序正在执行 SIGTERM 的 handler（也就是你写的那个 C 函数）。

* **如果这时 SIGINT 到达，会怎样？**

---

# ✔ 结果：SIGINT 依旧走它自己的处理方式（SIG_IGN） → 被内核忽略

**不会打断你正在执行的 SIGTERM handler。**

---

# 关键点解释（你必须理解的机制之一）

> **“进入某个信号的 handler，不会改变其他信号的处理方式。”**

也就是说：

* 你在进入 SIGTERM handler 时，只是“正在处理 SIGTERM”；
* 这不会影响你之前对 SIGINT 的设置（SIG_IGN）。

所以：

* SIGINT 来 → 看到处理动作是 SIG_IGN → 内核直接忽略
* 完全不会跳到用户态，不会中断当前 handler，不会造成任何重入。

就这么简单。

---

# ✔ 那哪些信号会在 handler 执行期间被自动屏蔽？

POSIX 规定——当一个信号 handler 开始执行时：

1. **当前这个信号** 会自动加入进程的信号屏蔽字
   （防止同一个信号重入）
2. 你在 `sa_mask` 里显式加的信号也会被屏蔽

例如：

```cpp
sigemptyset(&act.sa_mask);
sigaddset(&act.sa_mask, SIGINT);  // 在处理 SIGTERM 时屏蔽 SIGINT
act.sa_handler = sigterm_handler;
sigaction(SIGTERM, &act, NULL);
```

那执行 SIGTERM handler 时：

* SIGTERM 本身自动被屏蔽（防止重入）
* SIGINT 因被加入 `sa_mask`，也被屏蔽（不会递送，不会执行 handler）

**但屏蔽 ≠ 忽略：**

* 屏蔽后信号会变成 pending（排队），等 handler 退出后再处理
* 忽略（SIG_IGN）是直接无视，不入队、不递送

你现在的例子里：

```cpp
signal(SIGINT, SIG_IGN);  // 彻底忽略，不排队
```

所以即使不加入 `sa_mask`，SIGINT 也不会影响你，它根本不会排队、不会递送，就像从来没来过一样。

---

# ✔ 再给你一个你最关心的对照表（一定要看）

| 信号          | 处理方式            | handler 中到达时行为                                        |
| ----------- | --------------- | ----------------------------------------------------- |
| SIGTERM（当前） | handler         | 自动屏蔽，不会重入                                             |
| SIGINT      | **SIG_IGN**（忽略） | **直接忽略，不会打断，不会排队**                                    |
| 其它信号        | 默认动作            | 根据默认动作处理（可能 terminate 或 ignore），但不会跳你 handler（因为你没安装） |

---

# ✔ 最后用一句完全确定性的总结

> **你忽略（SIG_IGN）了的信号，就算在 handler 里到达，也永远不会打断当前 handler。
> 它仍然是忽略、无递送、无排队。**

它和你正在处理的信号，完全是两个独立系统，不会互相影响。

---

如果你愿意，我还能给你画一张信号递送流程图，把：

* “忽略”
* “屏蔽”
* “pending”
* “handler”
* “默认动作”

这些状态讲得特别清楚，让你对信号彻底吃透。



