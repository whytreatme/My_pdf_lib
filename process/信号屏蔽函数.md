arthur，这段代码思路是对的：进关键区前把 `SIGINT`（Ctrl+C）临时屏蔽，结束后恢复。你要系统地掌握两块：**信号屏蔽/信号集相关函数**，以及 **`sigaction` 安装处理器**。我把“能直接用”的要点、坑点、常见写法，一次讲清。

# 信号屏蔽（blocking/masking）

## 1) 信号集工具箱（操作 `sigset_t`）

* `sigemptyset(sigset_t *set)`：置空。
* `sigfillset(sigset_t *set)`：置满（除了不可屏蔽的 `SIGKILL`/`SIGSTOP`）。
* `sigaddset(sigset_t *set, int signo)` / `sigdelset`：加/删某个信号。
* `sigismember(const sigset_t *set, int signo)`：检查成员。
* `sigandset/sigorset/sigxorset`（部分系统有）：集合运算（Linux有GNU扩展 `sigorset/sigandset`）。

## 2) 设置/查询当前线程的信号屏蔽

* `sigprocmask(int how, const sigset_t *set, sigset_t *oldset)`

  * `how` 取值：

    * `SIG_BLOCK`：把 `set` 里的信号加入屏蔽mask。
    * `SIG_UNBLOCK`：把 `set` 里的信号从屏蔽mask移除。
    * `SIG_SETMASK`：直接替换当前mask为 `set`。
  * `oldset` 可选，用来保存调用前的mask；**进关键区前保存旧mask，出关键区时恢复**是基本操作。
* 线程注意：**信号屏蔽是“线程级”**。多线程程序里请用 `pthread_sigmask`（语义一致）而不是 `sigprocmask`。

## 3) 屏蔽的作用 & “待处理队列”

* 被屏蔽的信号**不会立刻递送**，而是变成**待处理（pending）**。
* 待处理标准信号是**合并的**（coalesce）：相同信号来多个只算一个；实时信号（`SIGRTMIN+N`）会**排队**不丢失顺序与次数。
* 可用 `sigpending(sigset_t *set)` 查看当前待处理信号集合。
* 绝对屏蔽不了：`SIGKILL`、`SIGSTOP`。

## 4) 典型用法：保护关键区

你写的就是这种：

```c
sigset_t newset, oldset;
sigemptyset(&newset);
sigaddset(&newset, SIGINT);
sigprocmask(SIG_BLOCK, &newset, &oldset);   // 进入关键区前屏蔽

critical_database_operation();              // 期间 Ctrl+C 不会中断

sigprocmask(SIG_SETMASK, &oldset, NULL);    // 恢复原mask（退出关键区）
```

**语义**：关键区期间 `SIGINT` 可能累积为 pending；一旦你恢复旧mask，内核会立刻投递 pending `SIGINT`（要么执行处理器、要么终止，取决于处置方式）。

## 5) “无竞争地等待信号”：`sigsuspend`

如果你需要“先屏蔽→做事→再**原子地**解除屏蔽并睡眠等待一个信号”，别用 `sleep()` 之类，会有竞态，应该：

```c
sigset_t block, old, empty;
sigemptyset(&block);
sigaddset(&block, SIGINT);
sigprocmask(SIG_BLOCK, &block, &old);   // 先屏蔽 SIGINT，避免错过

/* ... 做准备工作 ... */

sigemptyset(&empty);                    // empty = 解除了 SIGINT 的集合
// 原子操作：把当前mask设为 empty（从而解除屏蔽），并挂起等待信号到来
sigsuspend(&empty);                     // 返回必定是 -1 且 errno=EINTR
// 被信号打断后恢复到调用前的屏蔽状态（POSIX保证）
sigprocmask(SIG_SETMASK, &old, NULL);
```

> **结论**：`sigsuspend` 是写“安全等待信号”的关键API，避免“先unblock，信号在你sleep前到达导致错过”的竞态。

---

# 安装信号处理器：`sigaction`

`signal()` 简单，但各系统语义差异大；**推荐用 `sigaction`**（更可控、可移植）。

## 1) 结构体关键字段

```c
struct sigaction {
    void     (*sa_handler)(int);              // 简单处理函数 或
    void     (*sa_sigaction)(int, siginfo_t *, void *); // 带详细信息
    sigset_t  sa_mask;                        // 处理器运行期间临时屏蔽的额外信号
    int       sa_flags;                       // 行为标志
};
```

* `sa_handler` 与 `sa_sigaction` 二选一。
* `sa_mask`：**进入处理器时内核会自动把这里的信号加到屏蔽mask**（处理器退出后自动撤销）。默认内核也会在处理器里屏蔽“当前正在处理的信号本身”，除非设置 `SA_NODEFER`。
* 常见 `sa_flags`：

  * `SA_RESTART`：尽量让被信号打断的**慢系统调用**自动重启（如 `read`/`write`/`nanosleep` 等，视系统而定）。你不想处理 `EINTR` 的话常用它。
  * `SA_SIGINFO`：启用 `sa_sigaction` 形式，可拿到 `siginfo_t`（发送者PID、`si_code` 等）。
  * `SA_RESETHAND`：处理一次后恢复为默认处置（一次性）。
  * `SA_NODEFER`：处理期间不自动屏蔽同一信号（允许重入，**一般别用**）。
  * `SA_NOCLDSTOP` / `SA_NOCLDWAIT`：对子进程相关信号 `SIGCHLD` 的特殊控制。

## 2) 最常用写法（简单处理器 + 自动重启）

```c
static volatile sig_atomic_t g_got_int = 0;

static void on_int(int signo) {
    g_got_int = 1;               // 只做“异步信号安全”的操作
}

void install_sigint_handler(void) {
    struct sigaction act;
    sigemptyset(&act.sa_mask);
    act.sa_handler = on_int;
    act.sa_flags   = SA_RESTART; // 让多数阻塞型syscall自动重启
    sigaction(SIGINT, &act, NULL);
}
```

> **重要纪律**：在处理器里只能做 **async-signal-safe** 的操作（`write`、`_exit`、`sigatomic_t` 赋值等）。**不要** `printf`、`malloc`、`std::cout`、`new` 等。

## 3) 获取更多信息（`SA_SIGINFO`）

```c
static void on_term(int signo, siginfo_t *si, void *ctx) {
    // 可读 si->si_pid, si->si_uid, si->si_code, si->si_value 等
}

void install_sigterm_handler() {
    struct sigaction act = {0};
    sigemptyset(&act.sa_mask);
    act.sa_sigaction = on_term;
    act.sa_flags = SA_SIGINFO | SA_RESTART;
    sigaction(SIGTERM, &act, NULL);
}
```

---

# 把两者配合起来：几个可靠范式

## 范式 A：关键区“延迟响应”Ctrl+C

目标：关键区不被 `SIGINT` 中断，但结束后**立刻按处置**。

```c
install_sigint_handler();                // 推荐先装好处理器
sigset_t block, old;
sigemptyset(&block);
sigaddset(&block, SIGINT);
sigprocmask(SIG_BLOCK, &block, &old);    // 关键区屏蔽

critical_database_operation();

sigprocmask(SIG_SETMASK, &old, NULL);    // 恢复 → 若期间来了 Ctrl+C，此时会立即递送
if (g_got_int) {
    // 自己决定怎么“善后”（保存、回滚、退出等）
}
```

## 范式 B：无竞态地“边解屏蔽边等待”

目标：做完准备，原子性地解除屏蔽并挂起，等一个信号来叫醒（比如优雅退出）。

```c
install_sigint_handler();

sigset_t block, old, empty;
sigemptyset(&block);
sigaddset(&block, SIGINT);
sigprocmask(SIG_BLOCK, &block, &old);

// ... 做准备 ...

sigemptyset(&empty);
while (!g_got_int) {
    sigsuspend(&empty);          // 原子：解屏蔽并等待
}
sigprocmask(SIG_SETMASK, &old, NULL);
// 收尾退出
```

## 范式 C：多线程程序——用 `pthread_sigmask` + 专门“信号线程”

* 主/工作线程：`pthread_sigmask(SIG_BLOCK, all_signals, NULL)` 全屏蔽。
* 专门的“信号线程”：用 `sigwaitinfo/sigtimedwait` 同步等待处理信号，再做统一处理（安全、清晰）。
  （这比在任意线程里跑异步处理器更容易写对。）

---

# 行为细节 & 易踩坑

* **`SIGKILL`/`SIGSTOP`**：不能屏蔽、不能捕获、不能忽略。
* **`execve`**：信号**屏蔽mask会被继承**；但**自定义处理器会重置为默认**（`SIG_IGN` 的忽略状态会继承）。牢记：`exec` 后要重新 `sigaction`。
* **`SA_RESTART` 不是万能**：不是所有系统调用都能重启；有些场景仍会返回 `-1, errno=EINTR`，你要处理重试逻辑。
* **处理器里只做“可重入/异步安全”的最小动作**：设置 `volatile sig_atomic_t` 标志、`write(2)` 输出、`_exit` 之类。
* **先装处理器再屏蔽/解屏蔽**：避免窗口期。
* **保存并恢复旧mask**：用 `sigprocmask(..., &old)` 把来时状态带回去，别粗暴清空。
* **标准信号会合并**：关键区太长可能只收到“一次”`SIGINT`。如果你需要逐次计数，用实时信号或自管队列。

---

# 最小可运行示例（Ctrl+C 延迟到关键区后再处理）

```c
#include <signal.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

static volatile sig_atomic_t g_got_int = 0;

static void on_int(int signo) {
    (void)signo;
    g_got_int = 1; // 只做可重入的最小动作
}

int main(void) {
    struct sigaction act;
    sigemptyset(&act.sa_mask);
    act.sa_handler = on_int;
    act.sa_flags   = SA_RESTART;
    if (sigaction(SIGINT, &act, NULL) == -1) {
        perror("sigaction");
        return 1;
    }

    sigset_t block, old;
    sigemptyset(&block);
    sigaddset(&block, SIGINT);
    if (sigprocmask(SIG_BLOCK, &block, &old) == -1) {
        perror("sigprocmask block");
        return 1;
    }

    // 关键区：这里不会被 Ctrl+C 打断
    write(STDOUT_FILENO, "关键操作开始\n", 18);
    sleep(5); // 模拟关键操作
    write(STDOUT_FILENO, "关键操作结束\n", 18);

    // 恢复屏蔽（若期间来了 Ctrl+C，此时会立即递送）
    if (sigprocmask(SIG_SETMASK, &old, NULL) == -1) {
        perror("sigprocmask restore");
        return 1;
    }

    if (g_got_int) {
        write(STDOUT_FILENO, "检测到 Ctrl+C，优雅退出\n", 36);
        // 做收尾...
        return 0;
    }

    write(STDOUT_FILENO, "未收到 Ctrl+C，继续执行\n", 36);
    // 继续后续逻辑...
    return 0;
}
```

---

# 你该怎么练（直给步骤）

1. **先把“工具箱”背熟**：`sigemptyset/sigaddset/sigprocmask/sigsuspend/sigpending`、`sigaction` 的四个要素（handler/siginfo/mask/flags）。
2. **写 3 段小程序**：

   * A：你的“关键区延迟响应”版本（上面示例），确认 pending 行为。
   * B：`sigsuspend` 无竞态等待，按 Ctrl+C 唤醒，再打印提示退出。
   * C：`SA_SIGINFO` 处理 `SIGTERM`，用另一个进程 `kill -TERM <pid>` 发送，打印 `si_pid/si_uid/si_code`。
3. **多线程再进阶**：主线程 `pthread_sigmask` 屏蔽，启动“信号线程”用 `sigwaitinfo` 统一处理。
4. **刻意练“EINTR”与 `SA_RESTART`**：写个 `read(STDIN)` 的循环，测试是否被打断与是否自动重启。

你要的是实打实的 API 练手，这套就是最小而完整的“信号屏蔽 + 处理器”地图。按这路线练，3–4 天够你把信号这一章吃透。加油，别怵 —— 会用这几把“扳手”，Linux 信号就没什么神秘的了。
