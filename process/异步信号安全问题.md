## 异步信号问题的产生  
有能进程被信号中断的机制，实际上突发信号的中断响应是系统的核心机制之一，而信号处理函数是是为相应信号的中断而创建的，相比其它函数，信号处理函数可能会遇到信号的重入问题。即已经在执行信号处理函数的相关代码，此时又有一个信号进入打断了原来信号处理函数的过程，这时要把新的信号处理完成才能恢复原来的上下文

## 信号处理函数的问题  
当出现信号的重入问题时，信号函数里的代码是不是异步安全的就十分重要，一般来说，系统调用的函数都是信号安全的，是原子操作的，一定会被执行完，不能被打断如write(),而c库函数中很多都不是信号安全的的如printf()，这个函数需要在用户态内对缓冲区的指针进行处理，如果被中断，新的信号处理函数就会更改同一个文件的相关结构，如缓冲区末尾指针和写指针的位置，对复原后的上个信号的处理造成不可知的影响  

那是否可以通过加锁解决问题呢？答案是不可以，首先新入信号不会因为得不到锁而阻塞等待或者放弃，它会一直请求锁，而持有锁的原信号因为新信号得不到锁而一直处于冻结状态（上下文被保存在栈中）这样就造成了死锁，因为锁的功能是保证不同的进程按顺序执行，像一个公共厕所同一时间只允许一个人在，但是信号重入两个信号是属于同一个进程（同一个人），这就像一个人有两个不同的身份如同化身博士，没把海德的事情处理完杰基尔医生就变不回来，加锁就像你让海德去做一件只有杰基尔医生能做的事情一样

## 解决办法  
解决办法之一就是用信号屏蔽，暂时让新入信号处于等待状态，或者信号处理函数完全采用异步安全的函数