# 问  
我想要在线程运行时输出一行日志，看看当前线程执行了哪个函数我该怎么做  

# 答  
`std::function<void()>` **在运行时拿不到“原始函数名”**（类型被擦除了，可能是 `bind/lambda`，并不对应一个可反查的符号）。想在工作线程里打印“当前执行哪个函数”，通用做法是：**提交任务时把名字一起带进去**，线程取出任务时打印这个名字。

下面给你一个最直接的改法：队列里不再只存 `std::function`，而是存 `{name, fn}`。

````cpp
#pragma once
#include <condition_variable>
#include <functional>
#include <mutex>
#include <queue>
#include <string>
#include <thread>
#include <vector>

class thpool {
public:
    thpool(int nums_threads, std::string threadtype = "worker");
    ~thpool();

    // 兼容旧接口：没有名字就当 unnamed
    void addTask(std::function<void()> task);

    // 新接口：带名字
    void addTask(std::string name, std::function<void()> task);

private:
    struct TaskItem {
        std::string name;
        std::function<void()> fn;
    };

    bool stop_{false};
    std::string thread_type_;
    std::vector<std::thread> threads;

    std::mutex mutex_;
    std::condition_variable tCondition;

    std::queue<TaskItem> taskQueue;
};
````

````cpp
#include "ThreadPool.h"
#include <string>
#include <unistd.h>
#include <sys/syscall.h>
#include <iostream>
#include <utility>

thpool::thpool(int nums_threads, std::string threadtype) : stop_(false), thread_type_(threadtype)
{
    for (int i = 0; i < nums_threads; i++) {
        threads.emplace_back([this] {
            printf("create %s thread(%ld).\n", thread_type_.c_str(), syscall(SYS_gettid));

            while (!stop_) {
                TaskItem item;
                {
                    std::unique_lock<std::mutex> lock(mutex_);
                    tCondition.wait(lock, [this] {
                        return stop_ || !taskQueue.empty();
                    });

                    if (stop_ && taskQueue.empty()) return;

                    item = std::move(taskQueue.front());
                    taskQueue.pop();
                }

                printf("%s thread(%ld) run task: %s\n",
                       thread_type_.c_str(),
                       syscall(SYS_gettid),
                       item.name.c_str());

                item.fn();
            }
        });
    }
}

void thpool::addTask(std::function<void()> task)
{
    addTask("unnamed", std::move(task));
}

void thpool::addTask(std::string name, std::function<void()> task)
{
    {
        std::unique_lock<std::mutex> lock(mutex_);
        taskQueue.push(TaskItem{std::move(name), std::move(task)});
    }
    tCondition.notify_one();
}

thpool::~thpool()
{
    stop_ = true;
    tCondition.notify_all();
    for (std::thread &th : threads)
        th.join();
}
````

使用时就能显式标注“函数名/任务名”：


如果你希望“自动取名”（比如把 `test` 解析成符号名），那只对**纯函数指针**比较可行（可用 `dladdr`），但对 `std::bind/lambda` 基本不可靠。你更倾向于“手动命名任务”，还是“只对函数指针尝试自动解析符号名”？   