# 阶段的划分

## 核心编译参数的分类（CXXFLAGS vs. LDFLAGS/LDLIBS）
你可以把编译过程看作两个主要阶段，参数也是按这两个阶段分配的：

### 编译阶段 (.cpp -> .o)： 使用 CXXFLAGS。它控制的是如何把源代码翻译成机器码。

标准控制：-std=c++17 规定代码遵循的语法版本。

优化与调试：-O2 负责优化速度，-g 负责保留调试符号（方便 gdb 调试）。

警告提示：-Wall -Wextra 能帮你发现代码中潜在的边界问题或逻辑漏洞。

头文件搜索：-Ipath 告诉编译器去哪里找 #include 的文件。

### 链接阶段 (.o -> 可执行文件/库)： 使用 LDFLAGS 和 LDLIBS。

库路径：-L/path（通常对应变量 LIBDIR）指定库文件存在的文件夹。

具体库名：-lxxx 指定要链接哪个库，比如 -lmylib。  

## 从源码到可执行文件的四个阶段
当你运行 g++ 时，背后其实发生了四个独立的转换过程：

### 预处理 (Preprocessing)

处理对象：# 开头的指令（如 #include、#define、#ifdef）。

逻辑：这是纯粹的“文本替换”。#include 会把头文件的内容完整地拷贝到源文件里；宏定义会被替换为具体的值。

产出：依然是代码，但已经“展开”了。

### 编译 (Compilation)

处理对象：预处理后的文本。

逻辑：编译器检查语法、语义，并将 C++ 代码翻译成汇编代码。

参数：CXXFLAGS 里的 -std、-Wall、-O2 都在这个阶段生效。

### 汇编 (Assembly)

逻辑：将汇编代码翻译成机器能读懂的二进制指令。

产出：目标文件 (Object File, .o)。目标文件已经是机器码，但它还没法运行，因为里面有很多“空位”（未解析的外部符号）。

### 链接 (Linking)

逻辑：这是最关键的一步。链接器把多个 .o 文件和外部的库文件打包在一起，解决符号引用问题（例如你在 a.cpp 里调用的函数实际上是在 b.cpp 里定义的，链接器负责把这两者连起来）。

参数：LDFLAGS 和 LDLIBS。  

## 外部依赖：头文件 vs 库文件
当你引入一个第三方库（比如一个图形库或线程池）时，你需要给编译器提供两样东西：

头文件 (.h / .hpp)

作用：告诉编译器函数“长什么样”（声明）。

参数：使用 -I (Include) 指定目录。如果没有这个，编译器在预处理阶段就会报“找不到文件”的错误。

库文件 (.a / .so)

作用：包含函数的“具体实现”（二进制代码）。

参数：使用 -L (Link) 指定目录，使用 -l 指定具体的库名。   

### Makefile书写实例
-I/path/to/include：预处理器去哪里找头文件。

-L/path/to/lib：链接器去哪里找库文件（对应变量 LIBDIR）。

-lxxx：链接器链接哪个具体的库（对应变量 LDLIBS）。

-fPIC：这通常出现在编译动态库时，意思是“生成位置无关代码”，允许动态库被加载到内存的任何位置。  

## 那动态库是已经是机器可执行的代码了吗？  
它确实是机器码，但它不是“完整的程序”
虽然动态库里全是机器码，但它和“可执行文件”（Executable）有一个本质区别：它没有“入口点”（Entry Point）。

可执行文件：像是一个有固定“大门”的建筑，操作系统知道从 main 函数开始运行。

动态库：像是一堆预减好的“功能模块”，里面虽然全是盖房子的机器指令，但没有“大门”。它必须由一个可执行文件在运行时“请”它进场，才能发挥作用。  

## 静态库的编译和链接过程  
[Canvas动图](https://gemini.google.com/share/51074573e0e9)  

## 动态库的编译和链接过程  
[Canvas动图](https://gemini.google.com/share/9824d826cedf)  

## 静态库链接只是填了个目标代码的地址，又不是把目标代码放进去，怎么会多占很多内存呢？为什么需要副本呢？  
其实你提到的“填个地址”并没有错，但它发生在代码已经被“放进去”之后。

简单来说，静态链接不仅仅是填地址，更是一个物理搬运的过程 📦。

1. 为什么说是“拷贝”而不是“指向”？
在静态链接时，链接器（Linker）会做两件事：

提取（Extraction）：它会从静态库（.a 文件）中找到你的程序用到的那些目标文件（.o），并将这些二进制机器码直接拷贝到最终的可执行文件中。

重定位（Relocation）：由于代码被搬到了新的地方（即可执行文件的代码段），原来的相对地址就变了。这时候，链接器才会像你说的，“填入”正确的物理或逻辑地址，确保 main 函数能找到跳转到库函数的路。

所以，静态库的代码实现是真正住进了你的可执行文件里，而不是留在原来的库文件里。  

## 那如果我修改了静态库，再链接，它难道不需要把原库函数代码给删除掉在拷贝新的吗?  
简单直接的回答是：链接过程并不是在一个现成的 .exe 或 app 文件内部进行“局部切除和缝补”，而是链接器（Linker）根据最新的零件，重新生产了一个完整的新文件，然后直接覆盖掉旧的文件。

为了让你透彻理解这个过程，我们从二进制布局和**偏移量（Offset）**这两个硬核维度来分析。

1. 为什么不能“删除并插入”？
在 C/C++ 的底层世界里，二进制可执行文件是一个连续的指令流。假设你的程序结构如下：

地址 0x100 - 0x200：main 函数的机器码

地址 0x201 - 0x300：库函数 foo 的机器码

如果你修改了 foo 的源码，重新编译后的机器码变长了（比如变成了 0x201 - 0x350），那么：

如果强行在原文件里“插入”，那么 foo 之后的序列都会被往后推。

这会导致程序里所有原本指向 0x301 之后地址的跳转指令全部失效。

二进制文件不是链表，它是数组。 在数组中间插入一个元素，代价是所有后续元素的物理位置都要移动。

2. 链接器（Linker）的真实物理操作
当你执行 g++ main.o libutils.a -o app 时，链接器（如 ld）的行为序列是这样的：

打开输出流：它向操作系统申请创建一个名为 app 的新文件（或者清空同名的旧文件）。

物理读取与搬运：

它读取 main.o 的数据段和代码段，写进 app 的开头。

它从 libutils.a 中找到你需要的那个 .o 块，紧随其后写进 app。

地址重定位（Relocation）：

这是最核心的一步。链接器扫描 main.o 留下的符号表。它发现 main 函数里有一个 CALL 指令，目标地址原本是 0000。

链接器根据当前 foo 函数在 app 文件里的最新物理偏移量，计算出正确的跳转地址，直接修改二进制流中的那几个字节。

关闭并保存：写入完成，新的 app 诞生，旧的 app 彻底消失。